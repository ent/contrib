// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"entgo.io/contrib/entproto/internal/entprototest/ent/migrate"
	"entgo.io/ent"
	"github.com/google/uuid"

	"entgo.io/contrib/entproto/internal/entprototest/ent/allmethodsservice"
	"entgo.io/contrib/entproto/internal/entprototest/ent/blogpost"
	"entgo.io/contrib/entproto/internal/entprototest/ent/category"
	"entgo.io/contrib/entproto/internal/entprototest/ent/dependsonskipped"
	"entgo.io/contrib/entproto/internal/entprototest/ent/duplicatenumbermessage"
	"entgo.io/contrib/entproto/internal/entprototest/ent/enumwithconflictingvalue"
	"entgo.io/contrib/entproto/internal/entprototest/ent/explicitskippedmessage"
	"entgo.io/contrib/entproto/internal/entprototest/ent/image"
	"entgo.io/contrib/entproto/internal/entprototest/ent/implicitskippedmessage"
	"entgo.io/contrib/entproto/internal/entprototest/ent/invalidfieldmessage"
	"entgo.io/contrib/entproto/internal/entprototest/ent/messagewithenum"
	"entgo.io/contrib/entproto/internal/entprototest/ent/messagewithfieldone"
	"entgo.io/contrib/entproto/internal/entprototest/ent/messagewithid"
	"entgo.io/contrib/entproto/internal/entprototest/ent/messagewithints"
	"entgo.io/contrib/entproto/internal/entprototest/ent/messagewithoptionals"
	"entgo.io/contrib/entproto/internal/entprototest/ent/messagewithpackagename"
	"entgo.io/contrib/entproto/internal/entprototest/ent/messagewithstrings"
	"entgo.io/contrib/entproto/internal/entprototest/ent/nobackref"
	"entgo.io/contrib/entproto/internal/entprototest/ent/onemethodservice"
	"entgo.io/contrib/entproto/internal/entprototest/ent/portal"
	"entgo.io/contrib/entproto/internal/entprototest/ent/skipedgeexample"
	"entgo.io/contrib/entproto/internal/entprototest/ent/twomethodservice"
	"entgo.io/contrib/entproto/internal/entprototest/ent/user"
	"entgo.io/contrib/entproto/internal/entprototest/ent/validmessage"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// AllMethodsService is the client for interacting with the AllMethodsService builders.
	AllMethodsService *AllMethodsServiceClient
	// BlogPost is the client for interacting with the BlogPost builders.
	BlogPost *BlogPostClient
	// Category is the client for interacting with the Category builders.
	Category *CategoryClient
	// DependsOnSkipped is the client for interacting with the DependsOnSkipped builders.
	DependsOnSkipped *DependsOnSkippedClient
	// DuplicateNumberMessage is the client for interacting with the DuplicateNumberMessage builders.
	DuplicateNumberMessage *DuplicateNumberMessageClient
	// EnumWithConflictingValue is the client for interacting with the EnumWithConflictingValue builders.
	EnumWithConflictingValue *EnumWithConflictingValueClient
	// ExplicitSkippedMessage is the client for interacting with the ExplicitSkippedMessage builders.
	ExplicitSkippedMessage *ExplicitSkippedMessageClient
	// Image is the client for interacting with the Image builders.
	Image *ImageClient
	// ImplicitSkippedMessage is the client for interacting with the ImplicitSkippedMessage builders.
	ImplicitSkippedMessage *ImplicitSkippedMessageClient
	// InvalidFieldMessage is the client for interacting with the InvalidFieldMessage builders.
	InvalidFieldMessage *InvalidFieldMessageClient
	// MessageWithEnum is the client for interacting with the MessageWithEnum builders.
	MessageWithEnum *MessageWithEnumClient
	// MessageWithFieldOne is the client for interacting with the MessageWithFieldOne builders.
	MessageWithFieldOne *MessageWithFieldOneClient
	// MessageWithID is the client for interacting with the MessageWithID builders.
	MessageWithID *MessageWithIDClient
	// MessageWithInts is the client for interacting with the MessageWithInts builders.
	MessageWithInts *MessageWithIntsClient
	// MessageWithOptionals is the client for interacting with the MessageWithOptionals builders.
	MessageWithOptionals *MessageWithOptionalsClient
	// MessageWithPackageName is the client for interacting with the MessageWithPackageName builders.
	MessageWithPackageName *MessageWithPackageNameClient
	// MessageWithStrings is the client for interacting with the MessageWithStrings builders.
	MessageWithStrings *MessageWithStringsClient
	// NoBackref is the client for interacting with the NoBackref builders.
	NoBackref *NoBackrefClient
	// OneMethodService is the client for interacting with the OneMethodService builders.
	OneMethodService *OneMethodServiceClient
	// Portal is the client for interacting with the Portal builders.
	Portal *PortalClient
	// SkipEdgeExample is the client for interacting with the SkipEdgeExample builders.
	SkipEdgeExample *SkipEdgeExampleClient
	// TwoMethodService is the client for interacting with the TwoMethodService builders.
	TwoMethodService *TwoMethodServiceClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// ValidMessage is the client for interacting with the ValidMessage builders.
	ValidMessage *ValidMessageClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.AllMethodsService = NewAllMethodsServiceClient(c.config)
	c.BlogPost = NewBlogPostClient(c.config)
	c.Category = NewCategoryClient(c.config)
	c.DependsOnSkipped = NewDependsOnSkippedClient(c.config)
	c.DuplicateNumberMessage = NewDuplicateNumberMessageClient(c.config)
	c.EnumWithConflictingValue = NewEnumWithConflictingValueClient(c.config)
	c.ExplicitSkippedMessage = NewExplicitSkippedMessageClient(c.config)
	c.Image = NewImageClient(c.config)
	c.ImplicitSkippedMessage = NewImplicitSkippedMessageClient(c.config)
	c.InvalidFieldMessage = NewInvalidFieldMessageClient(c.config)
	c.MessageWithEnum = NewMessageWithEnumClient(c.config)
	c.MessageWithFieldOne = NewMessageWithFieldOneClient(c.config)
	c.MessageWithID = NewMessageWithIDClient(c.config)
	c.MessageWithInts = NewMessageWithIntsClient(c.config)
	c.MessageWithOptionals = NewMessageWithOptionalsClient(c.config)
	c.MessageWithPackageName = NewMessageWithPackageNameClient(c.config)
	c.MessageWithStrings = NewMessageWithStringsClient(c.config)
	c.NoBackref = NewNoBackrefClient(c.config)
	c.OneMethodService = NewOneMethodServiceClient(c.config)
	c.Portal = NewPortalClient(c.config)
	c.SkipEdgeExample = NewSkipEdgeExampleClient(c.config)
	c.TwoMethodService = NewTwoMethodServiceClient(c.config)
	c.User = NewUserClient(c.config)
	c.ValidMessage = NewValidMessageClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                      ctx,
		config:                   cfg,
		AllMethodsService:        NewAllMethodsServiceClient(cfg),
		BlogPost:                 NewBlogPostClient(cfg),
		Category:                 NewCategoryClient(cfg),
		DependsOnSkipped:         NewDependsOnSkippedClient(cfg),
		DuplicateNumberMessage:   NewDuplicateNumberMessageClient(cfg),
		EnumWithConflictingValue: NewEnumWithConflictingValueClient(cfg),
		ExplicitSkippedMessage:   NewExplicitSkippedMessageClient(cfg),
		Image:                    NewImageClient(cfg),
		ImplicitSkippedMessage:   NewImplicitSkippedMessageClient(cfg),
		InvalidFieldMessage:      NewInvalidFieldMessageClient(cfg),
		MessageWithEnum:          NewMessageWithEnumClient(cfg),
		MessageWithFieldOne:      NewMessageWithFieldOneClient(cfg),
		MessageWithID:            NewMessageWithIDClient(cfg),
		MessageWithInts:          NewMessageWithIntsClient(cfg),
		MessageWithOptionals:     NewMessageWithOptionalsClient(cfg),
		MessageWithPackageName:   NewMessageWithPackageNameClient(cfg),
		MessageWithStrings:       NewMessageWithStringsClient(cfg),
		NoBackref:                NewNoBackrefClient(cfg),
		OneMethodService:         NewOneMethodServiceClient(cfg),
		Portal:                   NewPortalClient(cfg),
		SkipEdgeExample:          NewSkipEdgeExampleClient(cfg),
		TwoMethodService:         NewTwoMethodServiceClient(cfg),
		User:                     NewUserClient(cfg),
		ValidMessage:             NewValidMessageClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                      ctx,
		config:                   cfg,
		AllMethodsService:        NewAllMethodsServiceClient(cfg),
		BlogPost:                 NewBlogPostClient(cfg),
		Category:                 NewCategoryClient(cfg),
		DependsOnSkipped:         NewDependsOnSkippedClient(cfg),
		DuplicateNumberMessage:   NewDuplicateNumberMessageClient(cfg),
		EnumWithConflictingValue: NewEnumWithConflictingValueClient(cfg),
		ExplicitSkippedMessage:   NewExplicitSkippedMessageClient(cfg),
		Image:                    NewImageClient(cfg),
		ImplicitSkippedMessage:   NewImplicitSkippedMessageClient(cfg),
		InvalidFieldMessage:      NewInvalidFieldMessageClient(cfg),
		MessageWithEnum:          NewMessageWithEnumClient(cfg),
		MessageWithFieldOne:      NewMessageWithFieldOneClient(cfg),
		MessageWithID:            NewMessageWithIDClient(cfg),
		MessageWithInts:          NewMessageWithIntsClient(cfg),
		MessageWithOptionals:     NewMessageWithOptionalsClient(cfg),
		MessageWithPackageName:   NewMessageWithPackageNameClient(cfg),
		MessageWithStrings:       NewMessageWithStringsClient(cfg),
		NoBackref:                NewNoBackrefClient(cfg),
		OneMethodService:         NewOneMethodServiceClient(cfg),
		Portal:                   NewPortalClient(cfg),
		SkipEdgeExample:          NewSkipEdgeExampleClient(cfg),
		TwoMethodService:         NewTwoMethodServiceClient(cfg),
		User:                     NewUserClient(cfg),
		ValidMessage:             NewValidMessageClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		AllMethodsService.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.AllMethodsService, c.BlogPost, c.Category, c.DependsOnSkipped,
		c.DuplicateNumberMessage, c.EnumWithConflictingValue, c.ExplicitSkippedMessage,
		c.Image, c.ImplicitSkippedMessage, c.InvalidFieldMessage, c.MessageWithEnum,
		c.MessageWithFieldOne, c.MessageWithID, c.MessageWithInts,
		c.MessageWithOptionals, c.MessageWithPackageName, c.MessageWithStrings,
		c.NoBackref, c.OneMethodService, c.Portal, c.SkipEdgeExample,
		c.TwoMethodService, c.User, c.ValidMessage,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.AllMethodsService, c.BlogPost, c.Category, c.DependsOnSkipped,
		c.DuplicateNumberMessage, c.EnumWithConflictingValue, c.ExplicitSkippedMessage,
		c.Image, c.ImplicitSkippedMessage, c.InvalidFieldMessage, c.MessageWithEnum,
		c.MessageWithFieldOne, c.MessageWithID, c.MessageWithInts,
		c.MessageWithOptionals, c.MessageWithPackageName, c.MessageWithStrings,
		c.NoBackref, c.OneMethodService, c.Portal, c.SkipEdgeExample,
		c.TwoMethodService, c.User, c.ValidMessage,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AllMethodsServiceMutation:
		return c.AllMethodsService.mutate(ctx, m)
	case *BlogPostMutation:
		return c.BlogPost.mutate(ctx, m)
	case *CategoryMutation:
		return c.Category.mutate(ctx, m)
	case *DependsOnSkippedMutation:
		return c.DependsOnSkipped.mutate(ctx, m)
	case *DuplicateNumberMessageMutation:
		return c.DuplicateNumberMessage.mutate(ctx, m)
	case *EnumWithConflictingValueMutation:
		return c.EnumWithConflictingValue.mutate(ctx, m)
	case *ExplicitSkippedMessageMutation:
		return c.ExplicitSkippedMessage.mutate(ctx, m)
	case *ImageMutation:
		return c.Image.mutate(ctx, m)
	case *ImplicitSkippedMessageMutation:
		return c.ImplicitSkippedMessage.mutate(ctx, m)
	case *InvalidFieldMessageMutation:
		return c.InvalidFieldMessage.mutate(ctx, m)
	case *MessageWithEnumMutation:
		return c.MessageWithEnum.mutate(ctx, m)
	case *MessageWithFieldOneMutation:
		return c.MessageWithFieldOne.mutate(ctx, m)
	case *MessageWithIDMutation:
		return c.MessageWithID.mutate(ctx, m)
	case *MessageWithIntsMutation:
		return c.MessageWithInts.mutate(ctx, m)
	case *MessageWithOptionalsMutation:
		return c.MessageWithOptionals.mutate(ctx, m)
	case *MessageWithPackageNameMutation:
		return c.MessageWithPackageName.mutate(ctx, m)
	case *MessageWithStringsMutation:
		return c.MessageWithStrings.mutate(ctx, m)
	case *NoBackrefMutation:
		return c.NoBackref.mutate(ctx, m)
	case *OneMethodServiceMutation:
		return c.OneMethodService.mutate(ctx, m)
	case *PortalMutation:
		return c.Portal.mutate(ctx, m)
	case *SkipEdgeExampleMutation:
		return c.SkipEdgeExample.mutate(ctx, m)
	case *TwoMethodServiceMutation:
		return c.TwoMethodService.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *ValidMessageMutation:
		return c.ValidMessage.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AllMethodsServiceClient is a client for the AllMethodsService schema.
type AllMethodsServiceClient struct {
	config
}

// NewAllMethodsServiceClient returns a client for the AllMethodsService from the given config.
func NewAllMethodsServiceClient(c config) *AllMethodsServiceClient {
	return &AllMethodsServiceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `allmethodsservice.Hooks(f(g(h())))`.
func (c *AllMethodsServiceClient) Use(hooks ...Hook) {
	c.hooks.AllMethodsService = append(c.hooks.AllMethodsService, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `allmethodsservice.Intercept(f(g(h())))`.
func (c *AllMethodsServiceClient) Intercept(interceptors ...Interceptor) {
	c.inters.AllMethodsService = append(c.inters.AllMethodsService, interceptors...)
}

// Create returns a builder for creating a AllMethodsService entity.
func (c *AllMethodsServiceClient) Create() *AllMethodsServiceCreate {
	mutation := newAllMethodsServiceMutation(c.config, OpCreate)
	return &AllMethodsServiceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AllMethodsService entities.
func (c *AllMethodsServiceClient) CreateBulk(builders ...*AllMethodsServiceCreate) *AllMethodsServiceCreateBulk {
	return &AllMethodsServiceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AllMethodsServiceClient) MapCreateBulk(slice any, setFunc func(*AllMethodsServiceCreate, int)) *AllMethodsServiceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AllMethodsServiceCreateBulk{err: fmt.Errorf("calling to AllMethodsServiceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AllMethodsServiceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AllMethodsServiceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AllMethodsService.
func (c *AllMethodsServiceClient) Update() *AllMethodsServiceUpdate {
	mutation := newAllMethodsServiceMutation(c.config, OpUpdate)
	return &AllMethodsServiceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AllMethodsServiceClient) UpdateOne(ams *AllMethodsService) *AllMethodsServiceUpdateOne {
	mutation := newAllMethodsServiceMutation(c.config, OpUpdateOne, withAllMethodsService(ams))
	return &AllMethodsServiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AllMethodsServiceClient) UpdateOneID(id int) *AllMethodsServiceUpdateOne {
	mutation := newAllMethodsServiceMutation(c.config, OpUpdateOne, withAllMethodsServiceID(id))
	return &AllMethodsServiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AllMethodsService.
func (c *AllMethodsServiceClient) Delete() *AllMethodsServiceDelete {
	mutation := newAllMethodsServiceMutation(c.config, OpDelete)
	return &AllMethodsServiceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AllMethodsServiceClient) DeleteOne(ams *AllMethodsService) *AllMethodsServiceDeleteOne {
	return c.DeleteOneID(ams.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AllMethodsServiceClient) DeleteOneID(id int) *AllMethodsServiceDeleteOne {
	builder := c.Delete().Where(allmethodsservice.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AllMethodsServiceDeleteOne{builder}
}

// Query returns a query builder for AllMethodsService.
func (c *AllMethodsServiceClient) Query() *AllMethodsServiceQuery {
	return &AllMethodsServiceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAllMethodsService},
		inters: c.Interceptors(),
	}
}

// Get returns a AllMethodsService entity by its id.
func (c *AllMethodsServiceClient) Get(ctx context.Context, id int) (*AllMethodsService, error) {
	return c.Query().Where(allmethodsservice.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AllMethodsServiceClient) GetX(ctx context.Context, id int) *AllMethodsService {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AllMethodsServiceClient) Hooks() []Hook {
	return c.hooks.AllMethodsService
}

// Interceptors returns the client interceptors.
func (c *AllMethodsServiceClient) Interceptors() []Interceptor {
	return c.inters.AllMethodsService
}

func (c *AllMethodsServiceClient) mutate(ctx context.Context, m *AllMethodsServiceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AllMethodsServiceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AllMethodsServiceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AllMethodsServiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AllMethodsServiceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AllMethodsService mutation op: %q", m.Op())
	}
}

// BlogPostClient is a client for the BlogPost schema.
type BlogPostClient struct {
	config
}

// NewBlogPostClient returns a client for the BlogPost from the given config.
func NewBlogPostClient(c config) *BlogPostClient {
	return &BlogPostClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `blogpost.Hooks(f(g(h())))`.
func (c *BlogPostClient) Use(hooks ...Hook) {
	c.hooks.BlogPost = append(c.hooks.BlogPost, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `blogpost.Intercept(f(g(h())))`.
func (c *BlogPostClient) Intercept(interceptors ...Interceptor) {
	c.inters.BlogPost = append(c.inters.BlogPost, interceptors...)
}

// Create returns a builder for creating a BlogPost entity.
func (c *BlogPostClient) Create() *BlogPostCreate {
	mutation := newBlogPostMutation(c.config, OpCreate)
	return &BlogPostCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BlogPost entities.
func (c *BlogPostClient) CreateBulk(builders ...*BlogPostCreate) *BlogPostCreateBulk {
	return &BlogPostCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *BlogPostClient) MapCreateBulk(slice any, setFunc func(*BlogPostCreate, int)) *BlogPostCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &BlogPostCreateBulk{err: fmt.Errorf("calling to BlogPostClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*BlogPostCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &BlogPostCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BlogPost.
func (c *BlogPostClient) Update() *BlogPostUpdate {
	mutation := newBlogPostMutation(c.config, OpUpdate)
	return &BlogPostUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BlogPostClient) UpdateOne(bp *BlogPost) *BlogPostUpdateOne {
	mutation := newBlogPostMutation(c.config, OpUpdateOne, withBlogPost(bp))
	return &BlogPostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BlogPostClient) UpdateOneID(id int) *BlogPostUpdateOne {
	mutation := newBlogPostMutation(c.config, OpUpdateOne, withBlogPostID(id))
	return &BlogPostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BlogPost.
func (c *BlogPostClient) Delete() *BlogPostDelete {
	mutation := newBlogPostMutation(c.config, OpDelete)
	return &BlogPostDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BlogPostClient) DeleteOne(bp *BlogPost) *BlogPostDeleteOne {
	return c.DeleteOneID(bp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BlogPostClient) DeleteOneID(id int) *BlogPostDeleteOne {
	builder := c.Delete().Where(blogpost.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BlogPostDeleteOne{builder}
}

// Query returns a query builder for BlogPost.
func (c *BlogPostClient) Query() *BlogPostQuery {
	return &BlogPostQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBlogPost},
		inters: c.Interceptors(),
	}
}

// Get returns a BlogPost entity by its id.
func (c *BlogPostClient) Get(ctx context.Context, id int) (*BlogPost, error) {
	return c.Query().Where(blogpost.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BlogPostClient) GetX(ctx context.Context, id int) *BlogPost {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAuthor queries the author edge of a BlogPost.
func (c *BlogPostClient) QueryAuthor(bp *BlogPost) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blogpost.Table, blogpost.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, blogpost.AuthorTable, blogpost.AuthorColumn),
		)
		fromV = sqlgraph.Neighbors(bp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCategories queries the categories edge of a BlogPost.
func (c *BlogPostClient) QueryCategories(bp *BlogPost) *CategoryQuery {
	query := (&CategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := bp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(blogpost.Table, blogpost.FieldID, id),
			sqlgraph.To(category.Table, category.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, blogpost.CategoriesTable, blogpost.CategoriesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(bp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *BlogPostClient) Hooks() []Hook {
	return c.hooks.BlogPost
}

// Interceptors returns the client interceptors.
func (c *BlogPostClient) Interceptors() []Interceptor {
	return c.inters.BlogPost
}

func (c *BlogPostClient) mutate(ctx context.Context, m *BlogPostMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BlogPostCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BlogPostUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BlogPostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BlogPostDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BlogPost mutation op: %q", m.Op())
	}
}

// CategoryClient is a client for the Category schema.
type CategoryClient struct {
	config
}

// NewCategoryClient returns a client for the Category from the given config.
func NewCategoryClient(c config) *CategoryClient {
	return &CategoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `category.Hooks(f(g(h())))`.
func (c *CategoryClient) Use(hooks ...Hook) {
	c.hooks.Category = append(c.hooks.Category, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `category.Intercept(f(g(h())))`.
func (c *CategoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.Category = append(c.inters.Category, interceptors...)
}

// Create returns a builder for creating a Category entity.
func (c *CategoryClient) Create() *CategoryCreate {
	mutation := newCategoryMutation(c.config, OpCreate)
	return &CategoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Category entities.
func (c *CategoryClient) CreateBulk(builders ...*CategoryCreate) *CategoryCreateBulk {
	return &CategoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CategoryClient) MapCreateBulk(slice any, setFunc func(*CategoryCreate, int)) *CategoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CategoryCreateBulk{err: fmt.Errorf("calling to CategoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CategoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CategoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Category.
func (c *CategoryClient) Update() *CategoryUpdate {
	mutation := newCategoryMutation(c.config, OpUpdate)
	return &CategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CategoryClient) UpdateOne(ca *Category) *CategoryUpdateOne {
	mutation := newCategoryMutation(c.config, OpUpdateOne, withCategory(ca))
	return &CategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CategoryClient) UpdateOneID(id int) *CategoryUpdateOne {
	mutation := newCategoryMutation(c.config, OpUpdateOne, withCategoryID(id))
	return &CategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Category.
func (c *CategoryClient) Delete() *CategoryDelete {
	mutation := newCategoryMutation(c.config, OpDelete)
	return &CategoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CategoryClient) DeleteOne(ca *Category) *CategoryDeleteOne {
	return c.DeleteOneID(ca.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CategoryClient) DeleteOneID(id int) *CategoryDeleteOne {
	builder := c.Delete().Where(category.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CategoryDeleteOne{builder}
}

// Query returns a query builder for Category.
func (c *CategoryClient) Query() *CategoryQuery {
	return &CategoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCategory},
		inters: c.Interceptors(),
	}
}

// Get returns a Category entity by its id.
func (c *CategoryClient) Get(ctx context.Context, id int) (*Category, error) {
	return c.Query().Where(category.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CategoryClient) GetX(ctx context.Context, id int) *Category {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBlogPosts queries the blog_posts edge of a Category.
func (c *CategoryClient) QueryBlogPosts(ca *Category) *BlogPostQuery {
	query := (&BlogPostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ca.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(category.Table, category.FieldID, id),
			sqlgraph.To(blogpost.Table, blogpost.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, category.BlogPostsTable, category.BlogPostsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(ca.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CategoryClient) Hooks() []Hook {
	return c.hooks.Category
}

// Interceptors returns the client interceptors.
func (c *CategoryClient) Interceptors() []Interceptor {
	return c.inters.Category
}

func (c *CategoryClient) mutate(ctx context.Context, m *CategoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CategoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CategoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Category mutation op: %q", m.Op())
	}
}

// DependsOnSkippedClient is a client for the DependsOnSkipped schema.
type DependsOnSkippedClient struct {
	config
}

// NewDependsOnSkippedClient returns a client for the DependsOnSkipped from the given config.
func NewDependsOnSkippedClient(c config) *DependsOnSkippedClient {
	return &DependsOnSkippedClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `dependsonskipped.Hooks(f(g(h())))`.
func (c *DependsOnSkippedClient) Use(hooks ...Hook) {
	c.hooks.DependsOnSkipped = append(c.hooks.DependsOnSkipped, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `dependsonskipped.Intercept(f(g(h())))`.
func (c *DependsOnSkippedClient) Intercept(interceptors ...Interceptor) {
	c.inters.DependsOnSkipped = append(c.inters.DependsOnSkipped, interceptors...)
}

// Create returns a builder for creating a DependsOnSkipped entity.
func (c *DependsOnSkippedClient) Create() *DependsOnSkippedCreate {
	mutation := newDependsOnSkippedMutation(c.config, OpCreate)
	return &DependsOnSkippedCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DependsOnSkipped entities.
func (c *DependsOnSkippedClient) CreateBulk(builders ...*DependsOnSkippedCreate) *DependsOnSkippedCreateBulk {
	return &DependsOnSkippedCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DependsOnSkippedClient) MapCreateBulk(slice any, setFunc func(*DependsOnSkippedCreate, int)) *DependsOnSkippedCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DependsOnSkippedCreateBulk{err: fmt.Errorf("calling to DependsOnSkippedClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DependsOnSkippedCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DependsOnSkippedCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DependsOnSkipped.
func (c *DependsOnSkippedClient) Update() *DependsOnSkippedUpdate {
	mutation := newDependsOnSkippedMutation(c.config, OpUpdate)
	return &DependsOnSkippedUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DependsOnSkippedClient) UpdateOne(dos *DependsOnSkipped) *DependsOnSkippedUpdateOne {
	mutation := newDependsOnSkippedMutation(c.config, OpUpdateOne, withDependsOnSkipped(dos))
	return &DependsOnSkippedUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DependsOnSkippedClient) UpdateOneID(id int) *DependsOnSkippedUpdateOne {
	mutation := newDependsOnSkippedMutation(c.config, OpUpdateOne, withDependsOnSkippedID(id))
	return &DependsOnSkippedUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DependsOnSkipped.
func (c *DependsOnSkippedClient) Delete() *DependsOnSkippedDelete {
	mutation := newDependsOnSkippedMutation(c.config, OpDelete)
	return &DependsOnSkippedDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DependsOnSkippedClient) DeleteOne(dos *DependsOnSkipped) *DependsOnSkippedDeleteOne {
	return c.DeleteOneID(dos.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DependsOnSkippedClient) DeleteOneID(id int) *DependsOnSkippedDeleteOne {
	builder := c.Delete().Where(dependsonskipped.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DependsOnSkippedDeleteOne{builder}
}

// Query returns a query builder for DependsOnSkipped.
func (c *DependsOnSkippedClient) Query() *DependsOnSkippedQuery {
	return &DependsOnSkippedQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDependsOnSkipped},
		inters: c.Interceptors(),
	}
}

// Get returns a DependsOnSkipped entity by its id.
func (c *DependsOnSkippedClient) Get(ctx context.Context, id int) (*DependsOnSkipped, error) {
	return c.Query().Where(dependsonskipped.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DependsOnSkippedClient) GetX(ctx context.Context, id int) *DependsOnSkipped {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySkipped queries the skipped edge of a DependsOnSkipped.
func (c *DependsOnSkippedClient) QuerySkipped(dos *DependsOnSkipped) *ImplicitSkippedMessageQuery {
	query := (&ImplicitSkippedMessageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := dos.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dependsonskipped.Table, dependsonskipped.FieldID, id),
			sqlgraph.To(implicitskippedmessage.Table, implicitskippedmessage.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, dependsonskipped.SkippedTable, dependsonskipped.SkippedColumn),
		)
		fromV = sqlgraph.Neighbors(dos.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DependsOnSkippedClient) Hooks() []Hook {
	return c.hooks.DependsOnSkipped
}

// Interceptors returns the client interceptors.
func (c *DependsOnSkippedClient) Interceptors() []Interceptor {
	return c.inters.DependsOnSkipped
}

func (c *DependsOnSkippedClient) mutate(ctx context.Context, m *DependsOnSkippedMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DependsOnSkippedCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DependsOnSkippedUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DependsOnSkippedUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DependsOnSkippedDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DependsOnSkipped mutation op: %q", m.Op())
	}
}

// DuplicateNumberMessageClient is a client for the DuplicateNumberMessage schema.
type DuplicateNumberMessageClient struct {
	config
}

// NewDuplicateNumberMessageClient returns a client for the DuplicateNumberMessage from the given config.
func NewDuplicateNumberMessageClient(c config) *DuplicateNumberMessageClient {
	return &DuplicateNumberMessageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `duplicatenumbermessage.Hooks(f(g(h())))`.
func (c *DuplicateNumberMessageClient) Use(hooks ...Hook) {
	c.hooks.DuplicateNumberMessage = append(c.hooks.DuplicateNumberMessage, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `duplicatenumbermessage.Intercept(f(g(h())))`.
func (c *DuplicateNumberMessageClient) Intercept(interceptors ...Interceptor) {
	c.inters.DuplicateNumberMessage = append(c.inters.DuplicateNumberMessage, interceptors...)
}

// Create returns a builder for creating a DuplicateNumberMessage entity.
func (c *DuplicateNumberMessageClient) Create() *DuplicateNumberMessageCreate {
	mutation := newDuplicateNumberMessageMutation(c.config, OpCreate)
	return &DuplicateNumberMessageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DuplicateNumberMessage entities.
func (c *DuplicateNumberMessageClient) CreateBulk(builders ...*DuplicateNumberMessageCreate) *DuplicateNumberMessageCreateBulk {
	return &DuplicateNumberMessageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DuplicateNumberMessageClient) MapCreateBulk(slice any, setFunc func(*DuplicateNumberMessageCreate, int)) *DuplicateNumberMessageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DuplicateNumberMessageCreateBulk{err: fmt.Errorf("calling to DuplicateNumberMessageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DuplicateNumberMessageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DuplicateNumberMessageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DuplicateNumberMessage.
func (c *DuplicateNumberMessageClient) Update() *DuplicateNumberMessageUpdate {
	mutation := newDuplicateNumberMessageMutation(c.config, OpUpdate)
	return &DuplicateNumberMessageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DuplicateNumberMessageClient) UpdateOne(dnm *DuplicateNumberMessage) *DuplicateNumberMessageUpdateOne {
	mutation := newDuplicateNumberMessageMutation(c.config, OpUpdateOne, withDuplicateNumberMessage(dnm))
	return &DuplicateNumberMessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DuplicateNumberMessageClient) UpdateOneID(id int) *DuplicateNumberMessageUpdateOne {
	mutation := newDuplicateNumberMessageMutation(c.config, OpUpdateOne, withDuplicateNumberMessageID(id))
	return &DuplicateNumberMessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DuplicateNumberMessage.
func (c *DuplicateNumberMessageClient) Delete() *DuplicateNumberMessageDelete {
	mutation := newDuplicateNumberMessageMutation(c.config, OpDelete)
	return &DuplicateNumberMessageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DuplicateNumberMessageClient) DeleteOne(dnm *DuplicateNumberMessage) *DuplicateNumberMessageDeleteOne {
	return c.DeleteOneID(dnm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DuplicateNumberMessageClient) DeleteOneID(id int) *DuplicateNumberMessageDeleteOne {
	builder := c.Delete().Where(duplicatenumbermessage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DuplicateNumberMessageDeleteOne{builder}
}

// Query returns a query builder for DuplicateNumberMessage.
func (c *DuplicateNumberMessageClient) Query() *DuplicateNumberMessageQuery {
	return &DuplicateNumberMessageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDuplicateNumberMessage},
		inters: c.Interceptors(),
	}
}

// Get returns a DuplicateNumberMessage entity by its id.
func (c *DuplicateNumberMessageClient) Get(ctx context.Context, id int) (*DuplicateNumberMessage, error) {
	return c.Query().Where(duplicatenumbermessage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DuplicateNumberMessageClient) GetX(ctx context.Context, id int) *DuplicateNumberMessage {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *DuplicateNumberMessageClient) Hooks() []Hook {
	return c.hooks.DuplicateNumberMessage
}

// Interceptors returns the client interceptors.
func (c *DuplicateNumberMessageClient) Interceptors() []Interceptor {
	return c.inters.DuplicateNumberMessage
}

func (c *DuplicateNumberMessageClient) mutate(ctx context.Context, m *DuplicateNumberMessageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DuplicateNumberMessageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DuplicateNumberMessageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DuplicateNumberMessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DuplicateNumberMessageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown DuplicateNumberMessage mutation op: %q", m.Op())
	}
}

// EnumWithConflictingValueClient is a client for the EnumWithConflictingValue schema.
type EnumWithConflictingValueClient struct {
	config
}

// NewEnumWithConflictingValueClient returns a client for the EnumWithConflictingValue from the given config.
func NewEnumWithConflictingValueClient(c config) *EnumWithConflictingValueClient {
	return &EnumWithConflictingValueClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `enumwithconflictingvalue.Hooks(f(g(h())))`.
func (c *EnumWithConflictingValueClient) Use(hooks ...Hook) {
	c.hooks.EnumWithConflictingValue = append(c.hooks.EnumWithConflictingValue, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `enumwithconflictingvalue.Intercept(f(g(h())))`.
func (c *EnumWithConflictingValueClient) Intercept(interceptors ...Interceptor) {
	c.inters.EnumWithConflictingValue = append(c.inters.EnumWithConflictingValue, interceptors...)
}

// Create returns a builder for creating a EnumWithConflictingValue entity.
func (c *EnumWithConflictingValueClient) Create() *EnumWithConflictingValueCreate {
	mutation := newEnumWithConflictingValueMutation(c.config, OpCreate)
	return &EnumWithConflictingValueCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EnumWithConflictingValue entities.
func (c *EnumWithConflictingValueClient) CreateBulk(builders ...*EnumWithConflictingValueCreate) *EnumWithConflictingValueCreateBulk {
	return &EnumWithConflictingValueCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *EnumWithConflictingValueClient) MapCreateBulk(slice any, setFunc func(*EnumWithConflictingValueCreate, int)) *EnumWithConflictingValueCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &EnumWithConflictingValueCreateBulk{err: fmt.Errorf("calling to EnumWithConflictingValueClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*EnumWithConflictingValueCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &EnumWithConflictingValueCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EnumWithConflictingValue.
func (c *EnumWithConflictingValueClient) Update() *EnumWithConflictingValueUpdate {
	mutation := newEnumWithConflictingValueMutation(c.config, OpUpdate)
	return &EnumWithConflictingValueUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EnumWithConflictingValueClient) UpdateOne(ewcv *EnumWithConflictingValue) *EnumWithConflictingValueUpdateOne {
	mutation := newEnumWithConflictingValueMutation(c.config, OpUpdateOne, withEnumWithConflictingValue(ewcv))
	return &EnumWithConflictingValueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EnumWithConflictingValueClient) UpdateOneID(id int) *EnumWithConflictingValueUpdateOne {
	mutation := newEnumWithConflictingValueMutation(c.config, OpUpdateOne, withEnumWithConflictingValueID(id))
	return &EnumWithConflictingValueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EnumWithConflictingValue.
func (c *EnumWithConflictingValueClient) Delete() *EnumWithConflictingValueDelete {
	mutation := newEnumWithConflictingValueMutation(c.config, OpDelete)
	return &EnumWithConflictingValueDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EnumWithConflictingValueClient) DeleteOne(ewcv *EnumWithConflictingValue) *EnumWithConflictingValueDeleteOne {
	return c.DeleteOneID(ewcv.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EnumWithConflictingValueClient) DeleteOneID(id int) *EnumWithConflictingValueDeleteOne {
	builder := c.Delete().Where(enumwithconflictingvalue.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EnumWithConflictingValueDeleteOne{builder}
}

// Query returns a query builder for EnumWithConflictingValue.
func (c *EnumWithConflictingValueClient) Query() *EnumWithConflictingValueQuery {
	return &EnumWithConflictingValueQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEnumWithConflictingValue},
		inters: c.Interceptors(),
	}
}

// Get returns a EnumWithConflictingValue entity by its id.
func (c *EnumWithConflictingValueClient) Get(ctx context.Context, id int) (*EnumWithConflictingValue, error) {
	return c.Query().Where(enumwithconflictingvalue.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EnumWithConflictingValueClient) GetX(ctx context.Context, id int) *EnumWithConflictingValue {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *EnumWithConflictingValueClient) Hooks() []Hook {
	return c.hooks.EnumWithConflictingValue
}

// Interceptors returns the client interceptors.
func (c *EnumWithConflictingValueClient) Interceptors() []Interceptor {
	return c.inters.EnumWithConflictingValue
}

func (c *EnumWithConflictingValueClient) mutate(ctx context.Context, m *EnumWithConflictingValueMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EnumWithConflictingValueCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EnumWithConflictingValueUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EnumWithConflictingValueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EnumWithConflictingValueDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EnumWithConflictingValue mutation op: %q", m.Op())
	}
}

// ExplicitSkippedMessageClient is a client for the ExplicitSkippedMessage schema.
type ExplicitSkippedMessageClient struct {
	config
}

// NewExplicitSkippedMessageClient returns a client for the ExplicitSkippedMessage from the given config.
func NewExplicitSkippedMessageClient(c config) *ExplicitSkippedMessageClient {
	return &ExplicitSkippedMessageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `explicitskippedmessage.Hooks(f(g(h())))`.
func (c *ExplicitSkippedMessageClient) Use(hooks ...Hook) {
	c.hooks.ExplicitSkippedMessage = append(c.hooks.ExplicitSkippedMessage, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `explicitskippedmessage.Intercept(f(g(h())))`.
func (c *ExplicitSkippedMessageClient) Intercept(interceptors ...Interceptor) {
	c.inters.ExplicitSkippedMessage = append(c.inters.ExplicitSkippedMessage, interceptors...)
}

// Create returns a builder for creating a ExplicitSkippedMessage entity.
func (c *ExplicitSkippedMessageClient) Create() *ExplicitSkippedMessageCreate {
	mutation := newExplicitSkippedMessageMutation(c.config, OpCreate)
	return &ExplicitSkippedMessageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ExplicitSkippedMessage entities.
func (c *ExplicitSkippedMessageClient) CreateBulk(builders ...*ExplicitSkippedMessageCreate) *ExplicitSkippedMessageCreateBulk {
	return &ExplicitSkippedMessageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ExplicitSkippedMessageClient) MapCreateBulk(slice any, setFunc func(*ExplicitSkippedMessageCreate, int)) *ExplicitSkippedMessageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ExplicitSkippedMessageCreateBulk{err: fmt.Errorf("calling to ExplicitSkippedMessageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ExplicitSkippedMessageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ExplicitSkippedMessageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ExplicitSkippedMessage.
func (c *ExplicitSkippedMessageClient) Update() *ExplicitSkippedMessageUpdate {
	mutation := newExplicitSkippedMessageMutation(c.config, OpUpdate)
	return &ExplicitSkippedMessageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ExplicitSkippedMessageClient) UpdateOne(esm *ExplicitSkippedMessage) *ExplicitSkippedMessageUpdateOne {
	mutation := newExplicitSkippedMessageMutation(c.config, OpUpdateOne, withExplicitSkippedMessage(esm))
	return &ExplicitSkippedMessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ExplicitSkippedMessageClient) UpdateOneID(id int) *ExplicitSkippedMessageUpdateOne {
	mutation := newExplicitSkippedMessageMutation(c.config, OpUpdateOne, withExplicitSkippedMessageID(id))
	return &ExplicitSkippedMessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ExplicitSkippedMessage.
func (c *ExplicitSkippedMessageClient) Delete() *ExplicitSkippedMessageDelete {
	mutation := newExplicitSkippedMessageMutation(c.config, OpDelete)
	return &ExplicitSkippedMessageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ExplicitSkippedMessageClient) DeleteOne(esm *ExplicitSkippedMessage) *ExplicitSkippedMessageDeleteOne {
	return c.DeleteOneID(esm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ExplicitSkippedMessageClient) DeleteOneID(id int) *ExplicitSkippedMessageDeleteOne {
	builder := c.Delete().Where(explicitskippedmessage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ExplicitSkippedMessageDeleteOne{builder}
}

// Query returns a query builder for ExplicitSkippedMessage.
func (c *ExplicitSkippedMessageClient) Query() *ExplicitSkippedMessageQuery {
	return &ExplicitSkippedMessageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeExplicitSkippedMessage},
		inters: c.Interceptors(),
	}
}

// Get returns a ExplicitSkippedMessage entity by its id.
func (c *ExplicitSkippedMessageClient) Get(ctx context.Context, id int) (*ExplicitSkippedMessage, error) {
	return c.Query().Where(explicitskippedmessage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ExplicitSkippedMessageClient) GetX(ctx context.Context, id int) *ExplicitSkippedMessage {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ExplicitSkippedMessageClient) Hooks() []Hook {
	return c.hooks.ExplicitSkippedMessage
}

// Interceptors returns the client interceptors.
func (c *ExplicitSkippedMessageClient) Interceptors() []Interceptor {
	return c.inters.ExplicitSkippedMessage
}

func (c *ExplicitSkippedMessageClient) mutate(ctx context.Context, m *ExplicitSkippedMessageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ExplicitSkippedMessageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ExplicitSkippedMessageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ExplicitSkippedMessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ExplicitSkippedMessageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ExplicitSkippedMessage mutation op: %q", m.Op())
	}
}

// ImageClient is a client for the Image schema.
type ImageClient struct {
	config
}

// NewImageClient returns a client for the Image from the given config.
func NewImageClient(c config) *ImageClient {
	return &ImageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `image.Hooks(f(g(h())))`.
func (c *ImageClient) Use(hooks ...Hook) {
	c.hooks.Image = append(c.hooks.Image, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `image.Intercept(f(g(h())))`.
func (c *ImageClient) Intercept(interceptors ...Interceptor) {
	c.inters.Image = append(c.inters.Image, interceptors...)
}

// Create returns a builder for creating a Image entity.
func (c *ImageClient) Create() *ImageCreate {
	mutation := newImageMutation(c.config, OpCreate)
	return &ImageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Image entities.
func (c *ImageClient) CreateBulk(builders ...*ImageCreate) *ImageCreateBulk {
	return &ImageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ImageClient) MapCreateBulk(slice any, setFunc func(*ImageCreate, int)) *ImageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ImageCreateBulk{err: fmt.Errorf("calling to ImageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ImageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ImageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Image.
func (c *ImageClient) Update() *ImageUpdate {
	mutation := newImageMutation(c.config, OpUpdate)
	return &ImageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ImageClient) UpdateOne(i *Image) *ImageUpdateOne {
	mutation := newImageMutation(c.config, OpUpdateOne, withImage(i))
	return &ImageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ImageClient) UpdateOneID(id uuid.UUID) *ImageUpdateOne {
	mutation := newImageMutation(c.config, OpUpdateOne, withImageID(id))
	return &ImageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Image.
func (c *ImageClient) Delete() *ImageDelete {
	mutation := newImageMutation(c.config, OpDelete)
	return &ImageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ImageClient) DeleteOne(i *Image) *ImageDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ImageClient) DeleteOneID(id uuid.UUID) *ImageDeleteOne {
	builder := c.Delete().Where(image.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ImageDeleteOne{builder}
}

// Query returns a query builder for Image.
func (c *ImageClient) Query() *ImageQuery {
	return &ImageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeImage},
		inters: c.Interceptors(),
	}
}

// Get returns a Image entity by its id.
func (c *ImageClient) Get(ctx context.Context, id uuid.UUID) (*Image, error) {
	return c.Query().Where(image.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ImageClient) GetX(ctx context.Context, id uuid.UUID) *Image {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUserProfilePic queries the user_profile_pic edge of a Image.
func (c *ImageClient) QueryUserProfilePic(i *Image) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(image.Table, image.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, image.UserProfilePicTable, image.UserProfilePicColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ImageClient) Hooks() []Hook {
	return c.hooks.Image
}

// Interceptors returns the client interceptors.
func (c *ImageClient) Interceptors() []Interceptor {
	return c.inters.Image
}

func (c *ImageClient) mutate(ctx context.Context, m *ImageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ImageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ImageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ImageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ImageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Image mutation op: %q", m.Op())
	}
}

// ImplicitSkippedMessageClient is a client for the ImplicitSkippedMessage schema.
type ImplicitSkippedMessageClient struct {
	config
}

// NewImplicitSkippedMessageClient returns a client for the ImplicitSkippedMessage from the given config.
func NewImplicitSkippedMessageClient(c config) *ImplicitSkippedMessageClient {
	return &ImplicitSkippedMessageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `implicitskippedmessage.Hooks(f(g(h())))`.
func (c *ImplicitSkippedMessageClient) Use(hooks ...Hook) {
	c.hooks.ImplicitSkippedMessage = append(c.hooks.ImplicitSkippedMessage, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `implicitskippedmessage.Intercept(f(g(h())))`.
func (c *ImplicitSkippedMessageClient) Intercept(interceptors ...Interceptor) {
	c.inters.ImplicitSkippedMessage = append(c.inters.ImplicitSkippedMessage, interceptors...)
}

// Create returns a builder for creating a ImplicitSkippedMessage entity.
func (c *ImplicitSkippedMessageClient) Create() *ImplicitSkippedMessageCreate {
	mutation := newImplicitSkippedMessageMutation(c.config, OpCreate)
	return &ImplicitSkippedMessageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ImplicitSkippedMessage entities.
func (c *ImplicitSkippedMessageClient) CreateBulk(builders ...*ImplicitSkippedMessageCreate) *ImplicitSkippedMessageCreateBulk {
	return &ImplicitSkippedMessageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ImplicitSkippedMessageClient) MapCreateBulk(slice any, setFunc func(*ImplicitSkippedMessageCreate, int)) *ImplicitSkippedMessageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ImplicitSkippedMessageCreateBulk{err: fmt.Errorf("calling to ImplicitSkippedMessageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ImplicitSkippedMessageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ImplicitSkippedMessageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ImplicitSkippedMessage.
func (c *ImplicitSkippedMessageClient) Update() *ImplicitSkippedMessageUpdate {
	mutation := newImplicitSkippedMessageMutation(c.config, OpUpdate)
	return &ImplicitSkippedMessageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ImplicitSkippedMessageClient) UpdateOne(ism *ImplicitSkippedMessage) *ImplicitSkippedMessageUpdateOne {
	mutation := newImplicitSkippedMessageMutation(c.config, OpUpdateOne, withImplicitSkippedMessage(ism))
	return &ImplicitSkippedMessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ImplicitSkippedMessageClient) UpdateOneID(id int) *ImplicitSkippedMessageUpdateOne {
	mutation := newImplicitSkippedMessageMutation(c.config, OpUpdateOne, withImplicitSkippedMessageID(id))
	return &ImplicitSkippedMessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ImplicitSkippedMessage.
func (c *ImplicitSkippedMessageClient) Delete() *ImplicitSkippedMessageDelete {
	mutation := newImplicitSkippedMessageMutation(c.config, OpDelete)
	return &ImplicitSkippedMessageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ImplicitSkippedMessageClient) DeleteOne(ism *ImplicitSkippedMessage) *ImplicitSkippedMessageDeleteOne {
	return c.DeleteOneID(ism.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ImplicitSkippedMessageClient) DeleteOneID(id int) *ImplicitSkippedMessageDeleteOne {
	builder := c.Delete().Where(implicitskippedmessage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ImplicitSkippedMessageDeleteOne{builder}
}

// Query returns a query builder for ImplicitSkippedMessage.
func (c *ImplicitSkippedMessageClient) Query() *ImplicitSkippedMessageQuery {
	return &ImplicitSkippedMessageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeImplicitSkippedMessage},
		inters: c.Interceptors(),
	}
}

// Get returns a ImplicitSkippedMessage entity by its id.
func (c *ImplicitSkippedMessageClient) Get(ctx context.Context, id int) (*ImplicitSkippedMessage, error) {
	return c.Query().Where(implicitskippedmessage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ImplicitSkippedMessageClient) GetX(ctx context.Context, id int) *ImplicitSkippedMessage {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ImplicitSkippedMessageClient) Hooks() []Hook {
	return c.hooks.ImplicitSkippedMessage
}

// Interceptors returns the client interceptors.
func (c *ImplicitSkippedMessageClient) Interceptors() []Interceptor {
	return c.inters.ImplicitSkippedMessage
}

func (c *ImplicitSkippedMessageClient) mutate(ctx context.Context, m *ImplicitSkippedMessageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ImplicitSkippedMessageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ImplicitSkippedMessageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ImplicitSkippedMessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ImplicitSkippedMessageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ImplicitSkippedMessage mutation op: %q", m.Op())
	}
}

// InvalidFieldMessageClient is a client for the InvalidFieldMessage schema.
type InvalidFieldMessageClient struct {
	config
}

// NewInvalidFieldMessageClient returns a client for the InvalidFieldMessage from the given config.
func NewInvalidFieldMessageClient(c config) *InvalidFieldMessageClient {
	return &InvalidFieldMessageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `invalidfieldmessage.Hooks(f(g(h())))`.
func (c *InvalidFieldMessageClient) Use(hooks ...Hook) {
	c.hooks.InvalidFieldMessage = append(c.hooks.InvalidFieldMessage, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `invalidfieldmessage.Intercept(f(g(h())))`.
func (c *InvalidFieldMessageClient) Intercept(interceptors ...Interceptor) {
	c.inters.InvalidFieldMessage = append(c.inters.InvalidFieldMessage, interceptors...)
}

// Create returns a builder for creating a InvalidFieldMessage entity.
func (c *InvalidFieldMessageClient) Create() *InvalidFieldMessageCreate {
	mutation := newInvalidFieldMessageMutation(c.config, OpCreate)
	return &InvalidFieldMessageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of InvalidFieldMessage entities.
func (c *InvalidFieldMessageClient) CreateBulk(builders ...*InvalidFieldMessageCreate) *InvalidFieldMessageCreateBulk {
	return &InvalidFieldMessageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InvalidFieldMessageClient) MapCreateBulk(slice any, setFunc func(*InvalidFieldMessageCreate, int)) *InvalidFieldMessageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InvalidFieldMessageCreateBulk{err: fmt.Errorf("calling to InvalidFieldMessageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InvalidFieldMessageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InvalidFieldMessageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for InvalidFieldMessage.
func (c *InvalidFieldMessageClient) Update() *InvalidFieldMessageUpdate {
	mutation := newInvalidFieldMessageMutation(c.config, OpUpdate)
	return &InvalidFieldMessageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InvalidFieldMessageClient) UpdateOne(ifm *InvalidFieldMessage) *InvalidFieldMessageUpdateOne {
	mutation := newInvalidFieldMessageMutation(c.config, OpUpdateOne, withInvalidFieldMessage(ifm))
	return &InvalidFieldMessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InvalidFieldMessageClient) UpdateOneID(id int) *InvalidFieldMessageUpdateOne {
	mutation := newInvalidFieldMessageMutation(c.config, OpUpdateOne, withInvalidFieldMessageID(id))
	return &InvalidFieldMessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for InvalidFieldMessage.
func (c *InvalidFieldMessageClient) Delete() *InvalidFieldMessageDelete {
	mutation := newInvalidFieldMessageMutation(c.config, OpDelete)
	return &InvalidFieldMessageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InvalidFieldMessageClient) DeleteOne(ifm *InvalidFieldMessage) *InvalidFieldMessageDeleteOne {
	return c.DeleteOneID(ifm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InvalidFieldMessageClient) DeleteOneID(id int) *InvalidFieldMessageDeleteOne {
	builder := c.Delete().Where(invalidfieldmessage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InvalidFieldMessageDeleteOne{builder}
}

// Query returns a query builder for InvalidFieldMessage.
func (c *InvalidFieldMessageClient) Query() *InvalidFieldMessageQuery {
	return &InvalidFieldMessageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInvalidFieldMessage},
		inters: c.Interceptors(),
	}
}

// Get returns a InvalidFieldMessage entity by its id.
func (c *InvalidFieldMessageClient) Get(ctx context.Context, id int) (*InvalidFieldMessage, error) {
	return c.Query().Where(invalidfieldmessage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InvalidFieldMessageClient) GetX(ctx context.Context, id int) *InvalidFieldMessage {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *InvalidFieldMessageClient) Hooks() []Hook {
	return c.hooks.InvalidFieldMessage
}

// Interceptors returns the client interceptors.
func (c *InvalidFieldMessageClient) Interceptors() []Interceptor {
	return c.inters.InvalidFieldMessage
}

func (c *InvalidFieldMessageClient) mutate(ctx context.Context, m *InvalidFieldMessageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InvalidFieldMessageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InvalidFieldMessageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InvalidFieldMessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InvalidFieldMessageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown InvalidFieldMessage mutation op: %q", m.Op())
	}
}

// MessageWithEnumClient is a client for the MessageWithEnum schema.
type MessageWithEnumClient struct {
	config
}

// NewMessageWithEnumClient returns a client for the MessageWithEnum from the given config.
func NewMessageWithEnumClient(c config) *MessageWithEnumClient {
	return &MessageWithEnumClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `messagewithenum.Hooks(f(g(h())))`.
func (c *MessageWithEnumClient) Use(hooks ...Hook) {
	c.hooks.MessageWithEnum = append(c.hooks.MessageWithEnum, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `messagewithenum.Intercept(f(g(h())))`.
func (c *MessageWithEnumClient) Intercept(interceptors ...Interceptor) {
	c.inters.MessageWithEnum = append(c.inters.MessageWithEnum, interceptors...)
}

// Create returns a builder for creating a MessageWithEnum entity.
func (c *MessageWithEnumClient) Create() *MessageWithEnumCreate {
	mutation := newMessageWithEnumMutation(c.config, OpCreate)
	return &MessageWithEnumCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MessageWithEnum entities.
func (c *MessageWithEnumClient) CreateBulk(builders ...*MessageWithEnumCreate) *MessageWithEnumCreateBulk {
	return &MessageWithEnumCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MessageWithEnumClient) MapCreateBulk(slice any, setFunc func(*MessageWithEnumCreate, int)) *MessageWithEnumCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MessageWithEnumCreateBulk{err: fmt.Errorf("calling to MessageWithEnumClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MessageWithEnumCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MessageWithEnumCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MessageWithEnum.
func (c *MessageWithEnumClient) Update() *MessageWithEnumUpdate {
	mutation := newMessageWithEnumMutation(c.config, OpUpdate)
	return &MessageWithEnumUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MessageWithEnumClient) UpdateOne(mwe *MessageWithEnum) *MessageWithEnumUpdateOne {
	mutation := newMessageWithEnumMutation(c.config, OpUpdateOne, withMessageWithEnum(mwe))
	return &MessageWithEnumUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MessageWithEnumClient) UpdateOneID(id int) *MessageWithEnumUpdateOne {
	mutation := newMessageWithEnumMutation(c.config, OpUpdateOne, withMessageWithEnumID(id))
	return &MessageWithEnumUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MessageWithEnum.
func (c *MessageWithEnumClient) Delete() *MessageWithEnumDelete {
	mutation := newMessageWithEnumMutation(c.config, OpDelete)
	return &MessageWithEnumDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MessageWithEnumClient) DeleteOne(mwe *MessageWithEnum) *MessageWithEnumDeleteOne {
	return c.DeleteOneID(mwe.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MessageWithEnumClient) DeleteOneID(id int) *MessageWithEnumDeleteOne {
	builder := c.Delete().Where(messagewithenum.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MessageWithEnumDeleteOne{builder}
}

// Query returns a query builder for MessageWithEnum.
func (c *MessageWithEnumClient) Query() *MessageWithEnumQuery {
	return &MessageWithEnumQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMessageWithEnum},
		inters: c.Interceptors(),
	}
}

// Get returns a MessageWithEnum entity by its id.
func (c *MessageWithEnumClient) Get(ctx context.Context, id int) (*MessageWithEnum, error) {
	return c.Query().Where(messagewithenum.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MessageWithEnumClient) GetX(ctx context.Context, id int) *MessageWithEnum {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *MessageWithEnumClient) Hooks() []Hook {
	return c.hooks.MessageWithEnum
}

// Interceptors returns the client interceptors.
func (c *MessageWithEnumClient) Interceptors() []Interceptor {
	return c.inters.MessageWithEnum
}

func (c *MessageWithEnumClient) mutate(ctx context.Context, m *MessageWithEnumMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MessageWithEnumCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MessageWithEnumUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MessageWithEnumUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MessageWithEnumDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MessageWithEnum mutation op: %q", m.Op())
	}
}

// MessageWithFieldOneClient is a client for the MessageWithFieldOne schema.
type MessageWithFieldOneClient struct {
	config
}

// NewMessageWithFieldOneClient returns a client for the MessageWithFieldOne from the given config.
func NewMessageWithFieldOneClient(c config) *MessageWithFieldOneClient {
	return &MessageWithFieldOneClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `messagewithfieldone.Hooks(f(g(h())))`.
func (c *MessageWithFieldOneClient) Use(hooks ...Hook) {
	c.hooks.MessageWithFieldOne = append(c.hooks.MessageWithFieldOne, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `messagewithfieldone.Intercept(f(g(h())))`.
func (c *MessageWithFieldOneClient) Intercept(interceptors ...Interceptor) {
	c.inters.MessageWithFieldOne = append(c.inters.MessageWithFieldOne, interceptors...)
}

// Create returns a builder for creating a MessageWithFieldOne entity.
func (c *MessageWithFieldOneClient) Create() *MessageWithFieldOneCreate {
	mutation := newMessageWithFieldOneMutation(c.config, OpCreate)
	return &MessageWithFieldOneCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MessageWithFieldOne entities.
func (c *MessageWithFieldOneClient) CreateBulk(builders ...*MessageWithFieldOneCreate) *MessageWithFieldOneCreateBulk {
	return &MessageWithFieldOneCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MessageWithFieldOneClient) MapCreateBulk(slice any, setFunc func(*MessageWithFieldOneCreate, int)) *MessageWithFieldOneCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MessageWithFieldOneCreateBulk{err: fmt.Errorf("calling to MessageWithFieldOneClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MessageWithFieldOneCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MessageWithFieldOneCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MessageWithFieldOne.
func (c *MessageWithFieldOneClient) Update() *MessageWithFieldOneUpdate {
	mutation := newMessageWithFieldOneMutation(c.config, OpUpdate)
	return &MessageWithFieldOneUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MessageWithFieldOneClient) UpdateOne(mwfo *MessageWithFieldOne) *MessageWithFieldOneUpdateOne {
	mutation := newMessageWithFieldOneMutation(c.config, OpUpdateOne, withMessageWithFieldOne(mwfo))
	return &MessageWithFieldOneUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MessageWithFieldOneClient) UpdateOneID(id int) *MessageWithFieldOneUpdateOne {
	mutation := newMessageWithFieldOneMutation(c.config, OpUpdateOne, withMessageWithFieldOneID(id))
	return &MessageWithFieldOneUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MessageWithFieldOne.
func (c *MessageWithFieldOneClient) Delete() *MessageWithFieldOneDelete {
	mutation := newMessageWithFieldOneMutation(c.config, OpDelete)
	return &MessageWithFieldOneDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MessageWithFieldOneClient) DeleteOne(mwfo *MessageWithFieldOne) *MessageWithFieldOneDeleteOne {
	return c.DeleteOneID(mwfo.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MessageWithFieldOneClient) DeleteOneID(id int) *MessageWithFieldOneDeleteOne {
	builder := c.Delete().Where(messagewithfieldone.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MessageWithFieldOneDeleteOne{builder}
}

// Query returns a query builder for MessageWithFieldOne.
func (c *MessageWithFieldOneClient) Query() *MessageWithFieldOneQuery {
	return &MessageWithFieldOneQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMessageWithFieldOne},
		inters: c.Interceptors(),
	}
}

// Get returns a MessageWithFieldOne entity by its id.
func (c *MessageWithFieldOneClient) Get(ctx context.Context, id int) (*MessageWithFieldOne, error) {
	return c.Query().Where(messagewithfieldone.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MessageWithFieldOneClient) GetX(ctx context.Context, id int) *MessageWithFieldOne {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *MessageWithFieldOneClient) Hooks() []Hook {
	return c.hooks.MessageWithFieldOne
}

// Interceptors returns the client interceptors.
func (c *MessageWithFieldOneClient) Interceptors() []Interceptor {
	return c.inters.MessageWithFieldOne
}

func (c *MessageWithFieldOneClient) mutate(ctx context.Context, m *MessageWithFieldOneMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MessageWithFieldOneCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MessageWithFieldOneUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MessageWithFieldOneUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MessageWithFieldOneDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MessageWithFieldOne mutation op: %q", m.Op())
	}
}

// MessageWithIDClient is a client for the MessageWithID schema.
type MessageWithIDClient struct {
	config
}

// NewMessageWithIDClient returns a client for the MessageWithID from the given config.
func NewMessageWithIDClient(c config) *MessageWithIDClient {
	return &MessageWithIDClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `messagewithid.Hooks(f(g(h())))`.
func (c *MessageWithIDClient) Use(hooks ...Hook) {
	c.hooks.MessageWithID = append(c.hooks.MessageWithID, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `messagewithid.Intercept(f(g(h())))`.
func (c *MessageWithIDClient) Intercept(interceptors ...Interceptor) {
	c.inters.MessageWithID = append(c.inters.MessageWithID, interceptors...)
}

// Create returns a builder for creating a MessageWithID entity.
func (c *MessageWithIDClient) Create() *MessageWithIDCreate {
	mutation := newMessageWithIDMutation(c.config, OpCreate)
	return &MessageWithIDCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MessageWithID entities.
func (c *MessageWithIDClient) CreateBulk(builders ...*MessageWithIDCreate) *MessageWithIDCreateBulk {
	return &MessageWithIDCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MessageWithIDClient) MapCreateBulk(slice any, setFunc func(*MessageWithIDCreate, int)) *MessageWithIDCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MessageWithIDCreateBulk{err: fmt.Errorf("calling to MessageWithIDClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MessageWithIDCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MessageWithIDCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MessageWithID.
func (c *MessageWithIDClient) Update() *MessageWithIDUpdate {
	mutation := newMessageWithIDMutation(c.config, OpUpdate)
	return &MessageWithIDUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MessageWithIDClient) UpdateOne(mwi *MessageWithID) *MessageWithIDUpdateOne {
	mutation := newMessageWithIDMutation(c.config, OpUpdateOne, withMessageWithID(mwi))
	return &MessageWithIDUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MessageWithIDClient) UpdateOneID(id int32) *MessageWithIDUpdateOne {
	mutation := newMessageWithIDMutation(c.config, OpUpdateOne, withMessageWithIDID(id))
	return &MessageWithIDUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MessageWithID.
func (c *MessageWithIDClient) Delete() *MessageWithIDDelete {
	mutation := newMessageWithIDMutation(c.config, OpDelete)
	return &MessageWithIDDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MessageWithIDClient) DeleteOne(mwi *MessageWithID) *MessageWithIDDeleteOne {
	return c.DeleteOneID(mwi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MessageWithIDClient) DeleteOneID(id int32) *MessageWithIDDeleteOne {
	builder := c.Delete().Where(messagewithid.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MessageWithIDDeleteOne{builder}
}

// Query returns a query builder for MessageWithID.
func (c *MessageWithIDClient) Query() *MessageWithIDQuery {
	return &MessageWithIDQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMessageWithID},
		inters: c.Interceptors(),
	}
}

// Get returns a MessageWithID entity by its id.
func (c *MessageWithIDClient) Get(ctx context.Context, id int32) (*MessageWithID, error) {
	return c.Query().Where(messagewithid.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MessageWithIDClient) GetX(ctx context.Context, id int32) *MessageWithID {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *MessageWithIDClient) Hooks() []Hook {
	return c.hooks.MessageWithID
}

// Interceptors returns the client interceptors.
func (c *MessageWithIDClient) Interceptors() []Interceptor {
	return c.inters.MessageWithID
}

func (c *MessageWithIDClient) mutate(ctx context.Context, m *MessageWithIDMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MessageWithIDCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MessageWithIDUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MessageWithIDUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MessageWithIDDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MessageWithID mutation op: %q", m.Op())
	}
}

// MessageWithIntsClient is a client for the MessageWithInts schema.
type MessageWithIntsClient struct {
	config
}

// NewMessageWithIntsClient returns a client for the MessageWithInts from the given config.
func NewMessageWithIntsClient(c config) *MessageWithIntsClient {
	return &MessageWithIntsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `messagewithints.Hooks(f(g(h())))`.
func (c *MessageWithIntsClient) Use(hooks ...Hook) {
	c.hooks.MessageWithInts = append(c.hooks.MessageWithInts, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `messagewithints.Intercept(f(g(h())))`.
func (c *MessageWithIntsClient) Intercept(interceptors ...Interceptor) {
	c.inters.MessageWithInts = append(c.inters.MessageWithInts, interceptors...)
}

// Create returns a builder for creating a MessageWithInts entity.
func (c *MessageWithIntsClient) Create() *MessageWithIntsCreate {
	mutation := newMessageWithIntsMutation(c.config, OpCreate)
	return &MessageWithIntsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MessageWithInts entities.
func (c *MessageWithIntsClient) CreateBulk(builders ...*MessageWithIntsCreate) *MessageWithIntsCreateBulk {
	return &MessageWithIntsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MessageWithIntsClient) MapCreateBulk(slice any, setFunc func(*MessageWithIntsCreate, int)) *MessageWithIntsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MessageWithIntsCreateBulk{err: fmt.Errorf("calling to MessageWithIntsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MessageWithIntsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MessageWithIntsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MessageWithInts.
func (c *MessageWithIntsClient) Update() *MessageWithIntsUpdate {
	mutation := newMessageWithIntsMutation(c.config, OpUpdate)
	return &MessageWithIntsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MessageWithIntsClient) UpdateOne(mwi *MessageWithInts) *MessageWithIntsUpdateOne {
	mutation := newMessageWithIntsMutation(c.config, OpUpdateOne, withMessageWithInts(mwi))
	return &MessageWithIntsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MessageWithIntsClient) UpdateOneID(id int) *MessageWithIntsUpdateOne {
	mutation := newMessageWithIntsMutation(c.config, OpUpdateOne, withMessageWithIntsID(id))
	return &MessageWithIntsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MessageWithInts.
func (c *MessageWithIntsClient) Delete() *MessageWithIntsDelete {
	mutation := newMessageWithIntsMutation(c.config, OpDelete)
	return &MessageWithIntsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MessageWithIntsClient) DeleteOne(mwi *MessageWithInts) *MessageWithIntsDeleteOne {
	return c.DeleteOneID(mwi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MessageWithIntsClient) DeleteOneID(id int) *MessageWithIntsDeleteOne {
	builder := c.Delete().Where(messagewithints.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MessageWithIntsDeleteOne{builder}
}

// Query returns a query builder for MessageWithInts.
func (c *MessageWithIntsClient) Query() *MessageWithIntsQuery {
	return &MessageWithIntsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMessageWithInts},
		inters: c.Interceptors(),
	}
}

// Get returns a MessageWithInts entity by its id.
func (c *MessageWithIntsClient) Get(ctx context.Context, id int) (*MessageWithInts, error) {
	return c.Query().Where(messagewithints.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MessageWithIntsClient) GetX(ctx context.Context, id int) *MessageWithInts {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *MessageWithIntsClient) Hooks() []Hook {
	return c.hooks.MessageWithInts
}

// Interceptors returns the client interceptors.
func (c *MessageWithIntsClient) Interceptors() []Interceptor {
	return c.inters.MessageWithInts
}

func (c *MessageWithIntsClient) mutate(ctx context.Context, m *MessageWithIntsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MessageWithIntsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MessageWithIntsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MessageWithIntsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MessageWithIntsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MessageWithInts mutation op: %q", m.Op())
	}
}

// MessageWithOptionalsClient is a client for the MessageWithOptionals schema.
type MessageWithOptionalsClient struct {
	config
}

// NewMessageWithOptionalsClient returns a client for the MessageWithOptionals from the given config.
func NewMessageWithOptionalsClient(c config) *MessageWithOptionalsClient {
	return &MessageWithOptionalsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `messagewithoptionals.Hooks(f(g(h())))`.
func (c *MessageWithOptionalsClient) Use(hooks ...Hook) {
	c.hooks.MessageWithOptionals = append(c.hooks.MessageWithOptionals, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `messagewithoptionals.Intercept(f(g(h())))`.
func (c *MessageWithOptionalsClient) Intercept(interceptors ...Interceptor) {
	c.inters.MessageWithOptionals = append(c.inters.MessageWithOptionals, interceptors...)
}

// Create returns a builder for creating a MessageWithOptionals entity.
func (c *MessageWithOptionalsClient) Create() *MessageWithOptionalsCreate {
	mutation := newMessageWithOptionalsMutation(c.config, OpCreate)
	return &MessageWithOptionalsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MessageWithOptionals entities.
func (c *MessageWithOptionalsClient) CreateBulk(builders ...*MessageWithOptionalsCreate) *MessageWithOptionalsCreateBulk {
	return &MessageWithOptionalsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MessageWithOptionalsClient) MapCreateBulk(slice any, setFunc func(*MessageWithOptionalsCreate, int)) *MessageWithOptionalsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MessageWithOptionalsCreateBulk{err: fmt.Errorf("calling to MessageWithOptionalsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MessageWithOptionalsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MessageWithOptionalsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MessageWithOptionals.
func (c *MessageWithOptionalsClient) Update() *MessageWithOptionalsUpdate {
	mutation := newMessageWithOptionalsMutation(c.config, OpUpdate)
	return &MessageWithOptionalsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MessageWithOptionalsClient) UpdateOne(mwo *MessageWithOptionals) *MessageWithOptionalsUpdateOne {
	mutation := newMessageWithOptionalsMutation(c.config, OpUpdateOne, withMessageWithOptionals(mwo))
	return &MessageWithOptionalsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MessageWithOptionalsClient) UpdateOneID(id int) *MessageWithOptionalsUpdateOne {
	mutation := newMessageWithOptionalsMutation(c.config, OpUpdateOne, withMessageWithOptionalsID(id))
	return &MessageWithOptionalsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MessageWithOptionals.
func (c *MessageWithOptionalsClient) Delete() *MessageWithOptionalsDelete {
	mutation := newMessageWithOptionalsMutation(c.config, OpDelete)
	return &MessageWithOptionalsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MessageWithOptionalsClient) DeleteOne(mwo *MessageWithOptionals) *MessageWithOptionalsDeleteOne {
	return c.DeleteOneID(mwo.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MessageWithOptionalsClient) DeleteOneID(id int) *MessageWithOptionalsDeleteOne {
	builder := c.Delete().Where(messagewithoptionals.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MessageWithOptionalsDeleteOne{builder}
}

// Query returns a query builder for MessageWithOptionals.
func (c *MessageWithOptionalsClient) Query() *MessageWithOptionalsQuery {
	return &MessageWithOptionalsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMessageWithOptionals},
		inters: c.Interceptors(),
	}
}

// Get returns a MessageWithOptionals entity by its id.
func (c *MessageWithOptionalsClient) Get(ctx context.Context, id int) (*MessageWithOptionals, error) {
	return c.Query().Where(messagewithoptionals.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MessageWithOptionalsClient) GetX(ctx context.Context, id int) *MessageWithOptionals {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *MessageWithOptionalsClient) Hooks() []Hook {
	return c.hooks.MessageWithOptionals
}

// Interceptors returns the client interceptors.
func (c *MessageWithOptionalsClient) Interceptors() []Interceptor {
	return c.inters.MessageWithOptionals
}

func (c *MessageWithOptionalsClient) mutate(ctx context.Context, m *MessageWithOptionalsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MessageWithOptionalsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MessageWithOptionalsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MessageWithOptionalsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MessageWithOptionalsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MessageWithOptionals mutation op: %q", m.Op())
	}
}

// MessageWithPackageNameClient is a client for the MessageWithPackageName schema.
type MessageWithPackageNameClient struct {
	config
}

// NewMessageWithPackageNameClient returns a client for the MessageWithPackageName from the given config.
func NewMessageWithPackageNameClient(c config) *MessageWithPackageNameClient {
	return &MessageWithPackageNameClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `messagewithpackagename.Hooks(f(g(h())))`.
func (c *MessageWithPackageNameClient) Use(hooks ...Hook) {
	c.hooks.MessageWithPackageName = append(c.hooks.MessageWithPackageName, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `messagewithpackagename.Intercept(f(g(h())))`.
func (c *MessageWithPackageNameClient) Intercept(interceptors ...Interceptor) {
	c.inters.MessageWithPackageName = append(c.inters.MessageWithPackageName, interceptors...)
}

// Create returns a builder for creating a MessageWithPackageName entity.
func (c *MessageWithPackageNameClient) Create() *MessageWithPackageNameCreate {
	mutation := newMessageWithPackageNameMutation(c.config, OpCreate)
	return &MessageWithPackageNameCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MessageWithPackageName entities.
func (c *MessageWithPackageNameClient) CreateBulk(builders ...*MessageWithPackageNameCreate) *MessageWithPackageNameCreateBulk {
	return &MessageWithPackageNameCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MessageWithPackageNameClient) MapCreateBulk(slice any, setFunc func(*MessageWithPackageNameCreate, int)) *MessageWithPackageNameCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MessageWithPackageNameCreateBulk{err: fmt.Errorf("calling to MessageWithPackageNameClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MessageWithPackageNameCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MessageWithPackageNameCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MessageWithPackageName.
func (c *MessageWithPackageNameClient) Update() *MessageWithPackageNameUpdate {
	mutation := newMessageWithPackageNameMutation(c.config, OpUpdate)
	return &MessageWithPackageNameUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MessageWithPackageNameClient) UpdateOne(mwpn *MessageWithPackageName) *MessageWithPackageNameUpdateOne {
	mutation := newMessageWithPackageNameMutation(c.config, OpUpdateOne, withMessageWithPackageName(mwpn))
	return &MessageWithPackageNameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MessageWithPackageNameClient) UpdateOneID(id int) *MessageWithPackageNameUpdateOne {
	mutation := newMessageWithPackageNameMutation(c.config, OpUpdateOne, withMessageWithPackageNameID(id))
	return &MessageWithPackageNameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MessageWithPackageName.
func (c *MessageWithPackageNameClient) Delete() *MessageWithPackageNameDelete {
	mutation := newMessageWithPackageNameMutation(c.config, OpDelete)
	return &MessageWithPackageNameDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MessageWithPackageNameClient) DeleteOne(mwpn *MessageWithPackageName) *MessageWithPackageNameDeleteOne {
	return c.DeleteOneID(mwpn.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MessageWithPackageNameClient) DeleteOneID(id int) *MessageWithPackageNameDeleteOne {
	builder := c.Delete().Where(messagewithpackagename.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MessageWithPackageNameDeleteOne{builder}
}

// Query returns a query builder for MessageWithPackageName.
func (c *MessageWithPackageNameClient) Query() *MessageWithPackageNameQuery {
	return &MessageWithPackageNameQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMessageWithPackageName},
		inters: c.Interceptors(),
	}
}

// Get returns a MessageWithPackageName entity by its id.
func (c *MessageWithPackageNameClient) Get(ctx context.Context, id int) (*MessageWithPackageName, error) {
	return c.Query().Where(messagewithpackagename.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MessageWithPackageNameClient) GetX(ctx context.Context, id int) *MessageWithPackageName {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *MessageWithPackageNameClient) Hooks() []Hook {
	return c.hooks.MessageWithPackageName
}

// Interceptors returns the client interceptors.
func (c *MessageWithPackageNameClient) Interceptors() []Interceptor {
	return c.inters.MessageWithPackageName
}

func (c *MessageWithPackageNameClient) mutate(ctx context.Context, m *MessageWithPackageNameMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MessageWithPackageNameCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MessageWithPackageNameUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MessageWithPackageNameUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MessageWithPackageNameDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MessageWithPackageName mutation op: %q", m.Op())
	}
}

// MessageWithStringsClient is a client for the MessageWithStrings schema.
type MessageWithStringsClient struct {
	config
}

// NewMessageWithStringsClient returns a client for the MessageWithStrings from the given config.
func NewMessageWithStringsClient(c config) *MessageWithStringsClient {
	return &MessageWithStringsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `messagewithstrings.Hooks(f(g(h())))`.
func (c *MessageWithStringsClient) Use(hooks ...Hook) {
	c.hooks.MessageWithStrings = append(c.hooks.MessageWithStrings, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `messagewithstrings.Intercept(f(g(h())))`.
func (c *MessageWithStringsClient) Intercept(interceptors ...Interceptor) {
	c.inters.MessageWithStrings = append(c.inters.MessageWithStrings, interceptors...)
}

// Create returns a builder for creating a MessageWithStrings entity.
func (c *MessageWithStringsClient) Create() *MessageWithStringsCreate {
	mutation := newMessageWithStringsMutation(c.config, OpCreate)
	return &MessageWithStringsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MessageWithStrings entities.
func (c *MessageWithStringsClient) CreateBulk(builders ...*MessageWithStringsCreate) *MessageWithStringsCreateBulk {
	return &MessageWithStringsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MessageWithStringsClient) MapCreateBulk(slice any, setFunc func(*MessageWithStringsCreate, int)) *MessageWithStringsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MessageWithStringsCreateBulk{err: fmt.Errorf("calling to MessageWithStringsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MessageWithStringsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MessageWithStringsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MessageWithStrings.
func (c *MessageWithStringsClient) Update() *MessageWithStringsUpdate {
	mutation := newMessageWithStringsMutation(c.config, OpUpdate)
	return &MessageWithStringsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MessageWithStringsClient) UpdateOne(mws *MessageWithStrings) *MessageWithStringsUpdateOne {
	mutation := newMessageWithStringsMutation(c.config, OpUpdateOne, withMessageWithStrings(mws))
	return &MessageWithStringsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MessageWithStringsClient) UpdateOneID(id int) *MessageWithStringsUpdateOne {
	mutation := newMessageWithStringsMutation(c.config, OpUpdateOne, withMessageWithStringsID(id))
	return &MessageWithStringsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MessageWithStrings.
func (c *MessageWithStringsClient) Delete() *MessageWithStringsDelete {
	mutation := newMessageWithStringsMutation(c.config, OpDelete)
	return &MessageWithStringsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MessageWithStringsClient) DeleteOne(mws *MessageWithStrings) *MessageWithStringsDeleteOne {
	return c.DeleteOneID(mws.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MessageWithStringsClient) DeleteOneID(id int) *MessageWithStringsDeleteOne {
	builder := c.Delete().Where(messagewithstrings.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MessageWithStringsDeleteOne{builder}
}

// Query returns a query builder for MessageWithStrings.
func (c *MessageWithStringsClient) Query() *MessageWithStringsQuery {
	return &MessageWithStringsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMessageWithStrings},
		inters: c.Interceptors(),
	}
}

// Get returns a MessageWithStrings entity by its id.
func (c *MessageWithStringsClient) Get(ctx context.Context, id int) (*MessageWithStrings, error) {
	return c.Query().Where(messagewithstrings.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MessageWithStringsClient) GetX(ctx context.Context, id int) *MessageWithStrings {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *MessageWithStringsClient) Hooks() []Hook {
	return c.hooks.MessageWithStrings
}

// Interceptors returns the client interceptors.
func (c *MessageWithStringsClient) Interceptors() []Interceptor {
	return c.inters.MessageWithStrings
}

func (c *MessageWithStringsClient) mutate(ctx context.Context, m *MessageWithStringsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MessageWithStringsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MessageWithStringsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MessageWithStringsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MessageWithStringsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MessageWithStrings mutation op: %q", m.Op())
	}
}

// NoBackrefClient is a client for the NoBackref schema.
type NoBackrefClient struct {
	config
}

// NewNoBackrefClient returns a client for the NoBackref from the given config.
func NewNoBackrefClient(c config) *NoBackrefClient {
	return &NoBackrefClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `nobackref.Hooks(f(g(h())))`.
func (c *NoBackrefClient) Use(hooks ...Hook) {
	c.hooks.NoBackref = append(c.hooks.NoBackref, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `nobackref.Intercept(f(g(h())))`.
func (c *NoBackrefClient) Intercept(interceptors ...Interceptor) {
	c.inters.NoBackref = append(c.inters.NoBackref, interceptors...)
}

// Create returns a builder for creating a NoBackref entity.
func (c *NoBackrefClient) Create() *NoBackrefCreate {
	mutation := newNoBackrefMutation(c.config, OpCreate)
	return &NoBackrefCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of NoBackref entities.
func (c *NoBackrefClient) CreateBulk(builders ...*NoBackrefCreate) *NoBackrefCreateBulk {
	return &NoBackrefCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *NoBackrefClient) MapCreateBulk(slice any, setFunc func(*NoBackrefCreate, int)) *NoBackrefCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &NoBackrefCreateBulk{err: fmt.Errorf("calling to NoBackrefClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*NoBackrefCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &NoBackrefCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for NoBackref.
func (c *NoBackrefClient) Update() *NoBackrefUpdate {
	mutation := newNoBackrefMutation(c.config, OpUpdate)
	return &NoBackrefUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NoBackrefClient) UpdateOne(nb *NoBackref) *NoBackrefUpdateOne {
	mutation := newNoBackrefMutation(c.config, OpUpdateOne, withNoBackref(nb))
	return &NoBackrefUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NoBackrefClient) UpdateOneID(id int) *NoBackrefUpdateOne {
	mutation := newNoBackrefMutation(c.config, OpUpdateOne, withNoBackrefID(id))
	return &NoBackrefUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for NoBackref.
func (c *NoBackrefClient) Delete() *NoBackrefDelete {
	mutation := newNoBackrefMutation(c.config, OpDelete)
	return &NoBackrefDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NoBackrefClient) DeleteOne(nb *NoBackref) *NoBackrefDeleteOne {
	return c.DeleteOneID(nb.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NoBackrefClient) DeleteOneID(id int) *NoBackrefDeleteOne {
	builder := c.Delete().Where(nobackref.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NoBackrefDeleteOne{builder}
}

// Query returns a query builder for NoBackref.
func (c *NoBackrefClient) Query() *NoBackrefQuery {
	return &NoBackrefQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNoBackref},
		inters: c.Interceptors(),
	}
}

// Get returns a NoBackref entity by its id.
func (c *NoBackrefClient) Get(ctx context.Context, id int) (*NoBackref, error) {
	return c.Query().Where(nobackref.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NoBackrefClient) GetX(ctx context.Context, id int) *NoBackref {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryImages queries the images edge of a NoBackref.
func (c *NoBackrefClient) QueryImages(nb *NoBackref) *ImageQuery {
	query := (&ImageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := nb.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(nobackref.Table, nobackref.FieldID, id),
			sqlgraph.To(image.Table, image.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, nobackref.ImagesTable, nobackref.ImagesColumn),
		)
		fromV = sqlgraph.Neighbors(nb.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NoBackrefClient) Hooks() []Hook {
	return c.hooks.NoBackref
}

// Interceptors returns the client interceptors.
func (c *NoBackrefClient) Interceptors() []Interceptor {
	return c.inters.NoBackref
}

func (c *NoBackrefClient) mutate(ctx context.Context, m *NoBackrefMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NoBackrefCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NoBackrefUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NoBackrefUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NoBackrefDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown NoBackref mutation op: %q", m.Op())
	}
}

// OneMethodServiceClient is a client for the OneMethodService schema.
type OneMethodServiceClient struct {
	config
}

// NewOneMethodServiceClient returns a client for the OneMethodService from the given config.
func NewOneMethodServiceClient(c config) *OneMethodServiceClient {
	return &OneMethodServiceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `onemethodservice.Hooks(f(g(h())))`.
func (c *OneMethodServiceClient) Use(hooks ...Hook) {
	c.hooks.OneMethodService = append(c.hooks.OneMethodService, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `onemethodservice.Intercept(f(g(h())))`.
func (c *OneMethodServiceClient) Intercept(interceptors ...Interceptor) {
	c.inters.OneMethodService = append(c.inters.OneMethodService, interceptors...)
}

// Create returns a builder for creating a OneMethodService entity.
func (c *OneMethodServiceClient) Create() *OneMethodServiceCreate {
	mutation := newOneMethodServiceMutation(c.config, OpCreate)
	return &OneMethodServiceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OneMethodService entities.
func (c *OneMethodServiceClient) CreateBulk(builders ...*OneMethodServiceCreate) *OneMethodServiceCreateBulk {
	return &OneMethodServiceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OneMethodServiceClient) MapCreateBulk(slice any, setFunc func(*OneMethodServiceCreate, int)) *OneMethodServiceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OneMethodServiceCreateBulk{err: fmt.Errorf("calling to OneMethodServiceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OneMethodServiceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OneMethodServiceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OneMethodService.
func (c *OneMethodServiceClient) Update() *OneMethodServiceUpdate {
	mutation := newOneMethodServiceMutation(c.config, OpUpdate)
	return &OneMethodServiceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OneMethodServiceClient) UpdateOne(oms *OneMethodService) *OneMethodServiceUpdateOne {
	mutation := newOneMethodServiceMutation(c.config, OpUpdateOne, withOneMethodService(oms))
	return &OneMethodServiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OneMethodServiceClient) UpdateOneID(id int) *OneMethodServiceUpdateOne {
	mutation := newOneMethodServiceMutation(c.config, OpUpdateOne, withOneMethodServiceID(id))
	return &OneMethodServiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OneMethodService.
func (c *OneMethodServiceClient) Delete() *OneMethodServiceDelete {
	mutation := newOneMethodServiceMutation(c.config, OpDelete)
	return &OneMethodServiceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OneMethodServiceClient) DeleteOne(oms *OneMethodService) *OneMethodServiceDeleteOne {
	return c.DeleteOneID(oms.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OneMethodServiceClient) DeleteOneID(id int) *OneMethodServiceDeleteOne {
	builder := c.Delete().Where(onemethodservice.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OneMethodServiceDeleteOne{builder}
}

// Query returns a query builder for OneMethodService.
func (c *OneMethodServiceClient) Query() *OneMethodServiceQuery {
	return &OneMethodServiceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOneMethodService},
		inters: c.Interceptors(),
	}
}

// Get returns a OneMethodService entity by its id.
func (c *OneMethodServiceClient) Get(ctx context.Context, id int) (*OneMethodService, error) {
	return c.Query().Where(onemethodservice.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OneMethodServiceClient) GetX(ctx context.Context, id int) *OneMethodService {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *OneMethodServiceClient) Hooks() []Hook {
	return c.hooks.OneMethodService
}

// Interceptors returns the client interceptors.
func (c *OneMethodServiceClient) Interceptors() []Interceptor {
	return c.inters.OneMethodService
}

func (c *OneMethodServiceClient) mutate(ctx context.Context, m *OneMethodServiceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OneMethodServiceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OneMethodServiceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OneMethodServiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OneMethodServiceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OneMethodService mutation op: %q", m.Op())
	}
}

// PortalClient is a client for the Portal schema.
type PortalClient struct {
	config
}

// NewPortalClient returns a client for the Portal from the given config.
func NewPortalClient(c config) *PortalClient {
	return &PortalClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `portal.Hooks(f(g(h())))`.
func (c *PortalClient) Use(hooks ...Hook) {
	c.hooks.Portal = append(c.hooks.Portal, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `portal.Intercept(f(g(h())))`.
func (c *PortalClient) Intercept(interceptors ...Interceptor) {
	c.inters.Portal = append(c.inters.Portal, interceptors...)
}

// Create returns a builder for creating a Portal entity.
func (c *PortalClient) Create() *PortalCreate {
	mutation := newPortalMutation(c.config, OpCreate)
	return &PortalCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Portal entities.
func (c *PortalClient) CreateBulk(builders ...*PortalCreate) *PortalCreateBulk {
	return &PortalCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PortalClient) MapCreateBulk(slice any, setFunc func(*PortalCreate, int)) *PortalCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PortalCreateBulk{err: fmt.Errorf("calling to PortalClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PortalCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PortalCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Portal.
func (c *PortalClient) Update() *PortalUpdate {
	mutation := newPortalMutation(c.config, OpUpdate)
	return &PortalUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PortalClient) UpdateOne(po *Portal) *PortalUpdateOne {
	mutation := newPortalMutation(c.config, OpUpdateOne, withPortal(po))
	return &PortalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PortalClient) UpdateOneID(id int) *PortalUpdateOne {
	mutation := newPortalMutation(c.config, OpUpdateOne, withPortalID(id))
	return &PortalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Portal.
func (c *PortalClient) Delete() *PortalDelete {
	mutation := newPortalMutation(c.config, OpDelete)
	return &PortalDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PortalClient) DeleteOne(po *Portal) *PortalDeleteOne {
	return c.DeleteOneID(po.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PortalClient) DeleteOneID(id int) *PortalDeleteOne {
	builder := c.Delete().Where(portal.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PortalDeleteOne{builder}
}

// Query returns a query builder for Portal.
func (c *PortalClient) Query() *PortalQuery {
	return &PortalQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePortal},
		inters: c.Interceptors(),
	}
}

// Get returns a Portal entity by its id.
func (c *PortalClient) Get(ctx context.Context, id int) (*Portal, error) {
	return c.Query().Where(portal.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PortalClient) GetX(ctx context.Context, id int) *Portal {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCategory queries the category edge of a Portal.
func (c *PortalClient) QueryCategory(po *Portal) *CategoryQuery {
	query := (&CategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(portal.Table, portal.FieldID, id),
			sqlgraph.To(category.Table, category.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, portal.CategoryTable, portal.CategoryColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PortalClient) Hooks() []Hook {
	return c.hooks.Portal
}

// Interceptors returns the client interceptors.
func (c *PortalClient) Interceptors() []Interceptor {
	return c.inters.Portal
}

func (c *PortalClient) mutate(ctx context.Context, m *PortalMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PortalCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PortalUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PortalUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PortalDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Portal mutation op: %q", m.Op())
	}
}

// SkipEdgeExampleClient is a client for the SkipEdgeExample schema.
type SkipEdgeExampleClient struct {
	config
}

// NewSkipEdgeExampleClient returns a client for the SkipEdgeExample from the given config.
func NewSkipEdgeExampleClient(c config) *SkipEdgeExampleClient {
	return &SkipEdgeExampleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `skipedgeexample.Hooks(f(g(h())))`.
func (c *SkipEdgeExampleClient) Use(hooks ...Hook) {
	c.hooks.SkipEdgeExample = append(c.hooks.SkipEdgeExample, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `skipedgeexample.Intercept(f(g(h())))`.
func (c *SkipEdgeExampleClient) Intercept(interceptors ...Interceptor) {
	c.inters.SkipEdgeExample = append(c.inters.SkipEdgeExample, interceptors...)
}

// Create returns a builder for creating a SkipEdgeExample entity.
func (c *SkipEdgeExampleClient) Create() *SkipEdgeExampleCreate {
	mutation := newSkipEdgeExampleMutation(c.config, OpCreate)
	return &SkipEdgeExampleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of SkipEdgeExample entities.
func (c *SkipEdgeExampleClient) CreateBulk(builders ...*SkipEdgeExampleCreate) *SkipEdgeExampleCreateBulk {
	return &SkipEdgeExampleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SkipEdgeExampleClient) MapCreateBulk(slice any, setFunc func(*SkipEdgeExampleCreate, int)) *SkipEdgeExampleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SkipEdgeExampleCreateBulk{err: fmt.Errorf("calling to SkipEdgeExampleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SkipEdgeExampleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SkipEdgeExampleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for SkipEdgeExample.
func (c *SkipEdgeExampleClient) Update() *SkipEdgeExampleUpdate {
	mutation := newSkipEdgeExampleMutation(c.config, OpUpdate)
	return &SkipEdgeExampleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SkipEdgeExampleClient) UpdateOne(see *SkipEdgeExample) *SkipEdgeExampleUpdateOne {
	mutation := newSkipEdgeExampleMutation(c.config, OpUpdateOne, withSkipEdgeExample(see))
	return &SkipEdgeExampleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SkipEdgeExampleClient) UpdateOneID(id int) *SkipEdgeExampleUpdateOne {
	mutation := newSkipEdgeExampleMutation(c.config, OpUpdateOne, withSkipEdgeExampleID(id))
	return &SkipEdgeExampleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for SkipEdgeExample.
func (c *SkipEdgeExampleClient) Delete() *SkipEdgeExampleDelete {
	mutation := newSkipEdgeExampleMutation(c.config, OpDelete)
	return &SkipEdgeExampleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SkipEdgeExampleClient) DeleteOne(see *SkipEdgeExample) *SkipEdgeExampleDeleteOne {
	return c.DeleteOneID(see.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SkipEdgeExampleClient) DeleteOneID(id int) *SkipEdgeExampleDeleteOne {
	builder := c.Delete().Where(skipedgeexample.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SkipEdgeExampleDeleteOne{builder}
}

// Query returns a query builder for SkipEdgeExample.
func (c *SkipEdgeExampleClient) Query() *SkipEdgeExampleQuery {
	return &SkipEdgeExampleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSkipEdgeExample},
		inters: c.Interceptors(),
	}
}

// Get returns a SkipEdgeExample entity by its id.
func (c *SkipEdgeExampleClient) Get(ctx context.Context, id int) (*SkipEdgeExample, error) {
	return c.Query().Where(skipedgeexample.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SkipEdgeExampleClient) GetX(ctx context.Context, id int) *SkipEdgeExample {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a SkipEdgeExample.
func (c *SkipEdgeExampleClient) QueryUser(see *SkipEdgeExample) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := see.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(skipedgeexample.Table, skipedgeexample.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, skipedgeexample.UserTable, skipedgeexample.UserColumn),
		)
		fromV = sqlgraph.Neighbors(see.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SkipEdgeExampleClient) Hooks() []Hook {
	return c.hooks.SkipEdgeExample
}

// Interceptors returns the client interceptors.
func (c *SkipEdgeExampleClient) Interceptors() []Interceptor {
	return c.inters.SkipEdgeExample
}

func (c *SkipEdgeExampleClient) mutate(ctx context.Context, m *SkipEdgeExampleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SkipEdgeExampleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SkipEdgeExampleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SkipEdgeExampleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SkipEdgeExampleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown SkipEdgeExample mutation op: %q", m.Op())
	}
}

// TwoMethodServiceClient is a client for the TwoMethodService schema.
type TwoMethodServiceClient struct {
	config
}

// NewTwoMethodServiceClient returns a client for the TwoMethodService from the given config.
func NewTwoMethodServiceClient(c config) *TwoMethodServiceClient {
	return &TwoMethodServiceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `twomethodservice.Hooks(f(g(h())))`.
func (c *TwoMethodServiceClient) Use(hooks ...Hook) {
	c.hooks.TwoMethodService = append(c.hooks.TwoMethodService, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `twomethodservice.Intercept(f(g(h())))`.
func (c *TwoMethodServiceClient) Intercept(interceptors ...Interceptor) {
	c.inters.TwoMethodService = append(c.inters.TwoMethodService, interceptors...)
}

// Create returns a builder for creating a TwoMethodService entity.
func (c *TwoMethodServiceClient) Create() *TwoMethodServiceCreate {
	mutation := newTwoMethodServiceMutation(c.config, OpCreate)
	return &TwoMethodServiceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TwoMethodService entities.
func (c *TwoMethodServiceClient) CreateBulk(builders ...*TwoMethodServiceCreate) *TwoMethodServiceCreateBulk {
	return &TwoMethodServiceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TwoMethodServiceClient) MapCreateBulk(slice any, setFunc func(*TwoMethodServiceCreate, int)) *TwoMethodServiceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TwoMethodServiceCreateBulk{err: fmt.Errorf("calling to TwoMethodServiceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TwoMethodServiceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TwoMethodServiceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TwoMethodService.
func (c *TwoMethodServiceClient) Update() *TwoMethodServiceUpdate {
	mutation := newTwoMethodServiceMutation(c.config, OpUpdate)
	return &TwoMethodServiceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TwoMethodServiceClient) UpdateOne(tms *TwoMethodService) *TwoMethodServiceUpdateOne {
	mutation := newTwoMethodServiceMutation(c.config, OpUpdateOne, withTwoMethodService(tms))
	return &TwoMethodServiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TwoMethodServiceClient) UpdateOneID(id int) *TwoMethodServiceUpdateOne {
	mutation := newTwoMethodServiceMutation(c.config, OpUpdateOne, withTwoMethodServiceID(id))
	return &TwoMethodServiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TwoMethodService.
func (c *TwoMethodServiceClient) Delete() *TwoMethodServiceDelete {
	mutation := newTwoMethodServiceMutation(c.config, OpDelete)
	return &TwoMethodServiceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TwoMethodServiceClient) DeleteOne(tms *TwoMethodService) *TwoMethodServiceDeleteOne {
	return c.DeleteOneID(tms.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TwoMethodServiceClient) DeleteOneID(id int) *TwoMethodServiceDeleteOne {
	builder := c.Delete().Where(twomethodservice.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TwoMethodServiceDeleteOne{builder}
}

// Query returns a query builder for TwoMethodService.
func (c *TwoMethodServiceClient) Query() *TwoMethodServiceQuery {
	return &TwoMethodServiceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTwoMethodService},
		inters: c.Interceptors(),
	}
}

// Get returns a TwoMethodService entity by its id.
func (c *TwoMethodServiceClient) Get(ctx context.Context, id int) (*TwoMethodService, error) {
	return c.Query().Where(twomethodservice.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TwoMethodServiceClient) GetX(ctx context.Context, id int) *TwoMethodService {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TwoMethodServiceClient) Hooks() []Hook {
	return c.hooks.TwoMethodService
}

// Interceptors returns the client interceptors.
func (c *TwoMethodServiceClient) Interceptors() []Interceptor {
	return c.inters.TwoMethodService
}

func (c *TwoMethodServiceClient) mutate(ctx context.Context, m *TwoMethodServiceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TwoMethodServiceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TwoMethodServiceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TwoMethodServiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TwoMethodServiceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TwoMethodService mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryBlogPosts queries the blog_posts edge of a User.
func (c *UserClient) QueryBlogPosts(u *User) *BlogPostQuery {
	query := (&BlogPostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(blogpost.Table, blogpost.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.BlogPostsTable, user.BlogPostsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProfilePic queries the profile_pic edge of a User.
func (c *UserClient) QueryProfilePic(u *User) *ImageQuery {
	query := (&ImageClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(image.Table, image.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, user.ProfilePicTable, user.ProfilePicColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySkipEdge queries the skip_edge edge of a User.
func (c *UserClient) QuerySkipEdge(u *User) *SkipEdgeExampleQuery {
	query := (&SkipEdgeExampleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(skipedgeexample.Table, skipedgeexample.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.SkipEdgeTable, user.SkipEdgeColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// ValidMessageClient is a client for the ValidMessage schema.
type ValidMessageClient struct {
	config
}

// NewValidMessageClient returns a client for the ValidMessage from the given config.
func NewValidMessageClient(c config) *ValidMessageClient {
	return &ValidMessageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `validmessage.Hooks(f(g(h())))`.
func (c *ValidMessageClient) Use(hooks ...Hook) {
	c.hooks.ValidMessage = append(c.hooks.ValidMessage, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `validmessage.Intercept(f(g(h())))`.
func (c *ValidMessageClient) Intercept(interceptors ...Interceptor) {
	c.inters.ValidMessage = append(c.inters.ValidMessage, interceptors...)
}

// Create returns a builder for creating a ValidMessage entity.
func (c *ValidMessageClient) Create() *ValidMessageCreate {
	mutation := newValidMessageMutation(c.config, OpCreate)
	return &ValidMessageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ValidMessage entities.
func (c *ValidMessageClient) CreateBulk(builders ...*ValidMessageCreate) *ValidMessageCreateBulk {
	return &ValidMessageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ValidMessageClient) MapCreateBulk(slice any, setFunc func(*ValidMessageCreate, int)) *ValidMessageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ValidMessageCreateBulk{err: fmt.Errorf("calling to ValidMessageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ValidMessageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ValidMessageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ValidMessage.
func (c *ValidMessageClient) Update() *ValidMessageUpdate {
	mutation := newValidMessageMutation(c.config, OpUpdate)
	return &ValidMessageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ValidMessageClient) UpdateOne(vm *ValidMessage) *ValidMessageUpdateOne {
	mutation := newValidMessageMutation(c.config, OpUpdateOne, withValidMessage(vm))
	return &ValidMessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ValidMessageClient) UpdateOneID(id int) *ValidMessageUpdateOne {
	mutation := newValidMessageMutation(c.config, OpUpdateOne, withValidMessageID(id))
	return &ValidMessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ValidMessage.
func (c *ValidMessageClient) Delete() *ValidMessageDelete {
	mutation := newValidMessageMutation(c.config, OpDelete)
	return &ValidMessageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ValidMessageClient) DeleteOne(vm *ValidMessage) *ValidMessageDeleteOne {
	return c.DeleteOneID(vm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ValidMessageClient) DeleteOneID(id int) *ValidMessageDeleteOne {
	builder := c.Delete().Where(validmessage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ValidMessageDeleteOne{builder}
}

// Query returns a query builder for ValidMessage.
func (c *ValidMessageClient) Query() *ValidMessageQuery {
	return &ValidMessageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeValidMessage},
		inters: c.Interceptors(),
	}
}

// Get returns a ValidMessage entity by its id.
func (c *ValidMessageClient) Get(ctx context.Context, id int) (*ValidMessage, error) {
	return c.Query().Where(validmessage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ValidMessageClient) GetX(ctx context.Context, id int) *ValidMessage {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ValidMessageClient) Hooks() []Hook {
	return c.hooks.ValidMessage
}

// Interceptors returns the client interceptors.
func (c *ValidMessageClient) Interceptors() []Interceptor {
	return c.inters.ValidMessage
}

func (c *ValidMessageClient) mutate(ctx context.Context, m *ValidMessageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ValidMessageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ValidMessageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ValidMessageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ValidMessageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ValidMessage mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		AllMethodsService, BlogPost, Category, DependsOnSkipped, DuplicateNumberMessage,
		EnumWithConflictingValue, ExplicitSkippedMessage, Image,
		ImplicitSkippedMessage, InvalidFieldMessage, MessageWithEnum,
		MessageWithFieldOne, MessageWithID, MessageWithInts, MessageWithOptionals,
		MessageWithPackageName, MessageWithStrings, NoBackref, OneMethodService,
		Portal, SkipEdgeExample, TwoMethodService, User, ValidMessage []ent.Hook
	}
	inters struct {
		AllMethodsService, BlogPost, Category, DependsOnSkipped, DuplicateNumberMessage,
		EnumWithConflictingValue, ExplicitSkippedMessage, Image,
		ImplicitSkippedMessage, InvalidFieldMessage, MessageWithEnum,
		MessageWithFieldOne, MessageWithID, MessageWithInts, MessageWithOptionals,
		MessageWithPackageName, MessageWithStrings, NoBackref, OneMethodService,
		Portal, SkipEdgeExample, TwoMethodService, User, ValidMessage []ent.Interceptor
	}
)
