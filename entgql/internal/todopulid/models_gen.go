// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package todopulid

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"entgo.io/contrib/entgql"
	"entgo.io/contrib/entgql/internal/todopulid/ent"
	"entgo.io/contrib/entgql/internal/todopulid/ent/schema/pulid"
)

type NamedNode interface {
	IsNamedNode()
}

type CategoryTypes struct {
	Public *bool `json:"public,omitempty"`
}

type CategoryTypesInput struct {
	Public *bool `json:"public,omitempty"`
}

// CreateDirectiveExampleInput is used for create DirectiveExample object.
// Input was generated by ent.
type CreateDirectiveExampleInput struct {
	OnTypeField      *string `json:"onTypeField,omitempty"`
	OnMutationFields *string `json:"onMutationFields,omitempty"`
	OnMutationCreate *string `json:"onMutationCreate,omitempty"`
	OnMutationUpdate *string `json:"onMutationUpdate,omitempty"`
	OnAllFields      *string `json:"onAllFields,omitempty"`
}

type DirectiveExample struct {
	ID               pulid.ID `json:"id"`
	OnTypeField      *string  `json:"onTypeField,omitempty"`
	OnMutationFields *string  `json:"onMutationFields,omitempty"`
	OnMutationCreate *string  `json:"onMutationCreate,omitempty"`
	OnMutationUpdate *string  `json:"onMutationUpdate,omitempty"`
	OnAllFields      *string  `json:"onAllFields,omitempty"`
}

func (DirectiveExample) IsNode() {}

// DirectiveExampleWhereInput is used for filtering DirectiveExample objects.
// Input was generated by ent.
type DirectiveExampleWhereInput struct {
	Not *DirectiveExampleWhereInput   `json:"not,omitempty"`
	And []*DirectiveExampleWhereInput `json:"and,omitempty"`
	Or  []*DirectiveExampleWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNeq   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGt    *pulid.ID  `json:"idGT,omitempty"`
	IDGte   *pulid.ID  `json:"idGTE,omitempty"`
	IDLt    *pulid.ID  `json:"idLT,omitempty"`
	IDLte   *pulid.ID  `json:"idLTE,omitempty"`
	// on_type_field field predicates
	OnTypeField             *string  `json:"onTypeField,omitempty"`
	OnTypeFieldNeq          *string  `json:"onTypeFieldNEQ,omitempty"`
	OnTypeFieldIn           []string `json:"onTypeFieldIn,omitempty"`
	OnTypeFieldNotIn        []string `json:"onTypeFieldNotIn,omitempty"`
	OnTypeFieldGt           *string  `json:"onTypeFieldGT,omitempty"`
	OnTypeFieldGte          *string  `json:"onTypeFieldGTE,omitempty"`
	OnTypeFieldLt           *string  `json:"onTypeFieldLT,omitempty"`
	OnTypeFieldLte          *string  `json:"onTypeFieldLTE,omitempty"`
	OnTypeFieldContains     *string  `json:"onTypeFieldContains,omitempty"`
	OnTypeFieldHasPrefix    *string  `json:"onTypeFieldHasPrefix,omitempty"`
	OnTypeFieldHasSuffix    *string  `json:"onTypeFieldHasSuffix,omitempty"`
	OnTypeFieldIsNil        *bool    `json:"onTypeFieldIsNil,omitempty"`
	OnTypeFieldNotNil       *bool    `json:"onTypeFieldNotNil,omitempty"`
	OnTypeFieldEqualFold    *string  `json:"onTypeFieldEqualFold,omitempty"`
	OnTypeFieldContainsFold *string  `json:"onTypeFieldContainsFold,omitempty"`
	// on_mutation_fields field predicates
	OnMutationFields             *string  `json:"onMutationFields,omitempty"`
	OnMutationFieldsNeq          *string  `json:"onMutationFieldsNEQ,omitempty"`
	OnMutationFieldsIn           []string `json:"onMutationFieldsIn,omitempty"`
	OnMutationFieldsNotIn        []string `json:"onMutationFieldsNotIn,omitempty"`
	OnMutationFieldsGt           *string  `json:"onMutationFieldsGT,omitempty"`
	OnMutationFieldsGte          *string  `json:"onMutationFieldsGTE,omitempty"`
	OnMutationFieldsLt           *string  `json:"onMutationFieldsLT,omitempty"`
	OnMutationFieldsLte          *string  `json:"onMutationFieldsLTE,omitempty"`
	OnMutationFieldsContains     *string  `json:"onMutationFieldsContains,omitempty"`
	OnMutationFieldsHasPrefix    *string  `json:"onMutationFieldsHasPrefix,omitempty"`
	OnMutationFieldsHasSuffix    *string  `json:"onMutationFieldsHasSuffix,omitempty"`
	OnMutationFieldsIsNil        *bool    `json:"onMutationFieldsIsNil,omitempty"`
	OnMutationFieldsNotNil       *bool    `json:"onMutationFieldsNotNil,omitempty"`
	OnMutationFieldsEqualFold    *string  `json:"onMutationFieldsEqualFold,omitempty"`
	OnMutationFieldsContainsFold *string  `json:"onMutationFieldsContainsFold,omitempty"`
	// on_mutation_create field predicates
	OnMutationCreate             *string  `json:"onMutationCreate,omitempty"`
	OnMutationCreateNeq          *string  `json:"onMutationCreateNEQ,omitempty"`
	OnMutationCreateIn           []string `json:"onMutationCreateIn,omitempty"`
	OnMutationCreateNotIn        []string `json:"onMutationCreateNotIn,omitempty"`
	OnMutationCreateGt           *string  `json:"onMutationCreateGT,omitempty"`
	OnMutationCreateGte          *string  `json:"onMutationCreateGTE,omitempty"`
	OnMutationCreateLt           *string  `json:"onMutationCreateLT,omitempty"`
	OnMutationCreateLte          *string  `json:"onMutationCreateLTE,omitempty"`
	OnMutationCreateContains     *string  `json:"onMutationCreateContains,omitempty"`
	OnMutationCreateHasPrefix    *string  `json:"onMutationCreateHasPrefix,omitempty"`
	OnMutationCreateHasSuffix    *string  `json:"onMutationCreateHasSuffix,omitempty"`
	OnMutationCreateIsNil        *bool    `json:"onMutationCreateIsNil,omitempty"`
	OnMutationCreateNotNil       *bool    `json:"onMutationCreateNotNil,omitempty"`
	OnMutationCreateEqualFold    *string  `json:"onMutationCreateEqualFold,omitempty"`
	OnMutationCreateContainsFold *string  `json:"onMutationCreateContainsFold,omitempty"`
	// on_mutation_update field predicates
	OnMutationUpdate             *string  `json:"onMutationUpdate,omitempty"`
	OnMutationUpdateNeq          *string  `json:"onMutationUpdateNEQ,omitempty"`
	OnMutationUpdateIn           []string `json:"onMutationUpdateIn,omitempty"`
	OnMutationUpdateNotIn        []string `json:"onMutationUpdateNotIn,omitempty"`
	OnMutationUpdateGt           *string  `json:"onMutationUpdateGT,omitempty"`
	OnMutationUpdateGte          *string  `json:"onMutationUpdateGTE,omitempty"`
	OnMutationUpdateLt           *string  `json:"onMutationUpdateLT,omitempty"`
	OnMutationUpdateLte          *string  `json:"onMutationUpdateLTE,omitempty"`
	OnMutationUpdateContains     *string  `json:"onMutationUpdateContains,omitempty"`
	OnMutationUpdateHasPrefix    *string  `json:"onMutationUpdateHasPrefix,omitempty"`
	OnMutationUpdateHasSuffix    *string  `json:"onMutationUpdateHasSuffix,omitempty"`
	OnMutationUpdateIsNil        *bool    `json:"onMutationUpdateIsNil,omitempty"`
	OnMutationUpdateNotNil       *bool    `json:"onMutationUpdateNotNil,omitempty"`
	OnMutationUpdateEqualFold    *string  `json:"onMutationUpdateEqualFold,omitempty"`
	OnMutationUpdateContainsFold *string  `json:"onMutationUpdateContainsFold,omitempty"`
	// on_all_fields field predicates
	OnAllFields             *string  `json:"onAllFields,omitempty"`
	OnAllFieldsNeq          *string  `json:"onAllFieldsNEQ,omitempty"`
	OnAllFieldsIn           []string `json:"onAllFieldsIn,omitempty"`
	OnAllFieldsNotIn        []string `json:"onAllFieldsNotIn,omitempty"`
	OnAllFieldsGt           *string  `json:"onAllFieldsGT,omitempty"`
	OnAllFieldsGte          *string  `json:"onAllFieldsGTE,omitempty"`
	OnAllFieldsLt           *string  `json:"onAllFieldsLT,omitempty"`
	OnAllFieldsLte          *string  `json:"onAllFieldsLTE,omitempty"`
	OnAllFieldsContains     *string  `json:"onAllFieldsContains,omitempty"`
	OnAllFieldsHasPrefix    *string  `json:"onAllFieldsHasPrefix,omitempty"`
	OnAllFieldsHasSuffix    *string  `json:"onAllFieldsHasSuffix,omitempty"`
	OnAllFieldsIsNil        *bool    `json:"onAllFieldsIsNil,omitempty"`
	OnAllFieldsNotNil       *bool    `json:"onAllFieldsNotNil,omitempty"`
	OnAllFieldsEqualFold    *string  `json:"onAllFieldsEqualFold,omitempty"`
	OnAllFieldsContainsFold *string  `json:"onAllFieldsContainsFold,omitempty"`
}

type OneToMany struct {
	ID       pulid.ID     `json:"id"`
	Name     string       `json:"name"`
	Field2   *string      `json:"field2,omitempty"`
	Parent   *OneToMany   `json:"parent,omitempty"`
	Children []*OneToMany `json:"children,omitempty"`
}

func (OneToMany) IsNode() {}

// A connection to a list of items.
type OneToManyConnection struct {
	// A list of edges.
	Edges []*OneToManyEdge `json:"edges,omitempty"`
	// Information to aid in pagination.
	PageInfo *entgql.PageInfo[pulid.ID] `json:"pageInfo"`
	// Identifies the total count of items in the connection.
	TotalCount int `json:"totalCount"`
}

// An edge in a connection.
type OneToManyEdge struct {
	// The item at the end of the edge.
	Node *OneToMany `json:"node,omitempty"`
	// A cursor for use in pagination.
	Cursor entgql.Cursor[pulid.ID] `json:"cursor"`
}

// Ordering options for OneToMany connections
type OneToManyOrder struct {
	// The ordering direction.
	Direction entgql.OrderDirection `json:"direction"`
	// The field by which to order OneToManies.
	Field OneToManyOrderField `json:"field"`
}

// OneToManyWhereInput is used for filtering OneToMany objects.
// Input was generated by ent.
type OneToManyWhereInput struct {
	Not *OneToManyWhereInput   `json:"not,omitempty"`
	And []*OneToManyWhereInput `json:"and,omitempty"`
	Or  []*OneToManyWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNeq   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGt    *pulid.ID  `json:"idGT,omitempty"`
	IDGte   *pulid.ID  `json:"idGTE,omitempty"`
	IDLt    *pulid.ID  `json:"idLT,omitempty"`
	IDLte   *pulid.ID  `json:"idLTE,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
	// field2 field predicates
	Field2             *string  `json:"field2,omitempty"`
	Field2neq          *string  `json:"field2NEQ,omitempty"`
	Field2In           []string `json:"field2In,omitempty"`
	Field2NotIn        []string `json:"field2NotIn,omitempty"`
	Field2gt           *string  `json:"field2GT,omitempty"`
	Field2gte          *string  `json:"field2GTE,omitempty"`
	Field2lt           *string  `json:"field2LT,omitempty"`
	Field2lte          *string  `json:"field2LTE,omitempty"`
	Field2Contains     *string  `json:"field2Contains,omitempty"`
	Field2HasPrefix    *string  `json:"field2HasPrefix,omitempty"`
	Field2HasSuffix    *string  `json:"field2HasSuffix,omitempty"`
	Field2IsNil        *bool    `json:"field2IsNil,omitempty"`
	Field2NotNil       *bool    `json:"field2NotNil,omitempty"`
	Field2EqualFold    *string  `json:"field2EqualFold,omitempty"`
	Field2ContainsFold *string  `json:"field2ContainsFold,omitempty"`
	// parent edge predicates
	HasParent     *bool                  `json:"hasParent,omitempty"`
	HasParentWith []*OneToManyWhereInput `json:"hasParentWith,omitempty"`
	// children edge predicates
	HasChildren     *bool                  `json:"hasChildren,omitempty"`
	HasChildrenWith []*OneToManyWhereInput `json:"hasChildrenWith,omitempty"`
}

// OrganizationWhereInput is used for filtering Workspace objects.
// Input was generated by ent.
type OrganizationWhereInput struct {
	Not *OrganizationWhereInput   `json:"not,omitempty"`
	And []*OrganizationWhereInput `json:"and,omitempty"`
	Or  []*OrganizationWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNeq   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGt    *pulid.ID  `json:"idGT,omitempty"`
	IDGte   *pulid.ID  `json:"idGTE,omitempty"`
	IDLt    *pulid.ID  `json:"idLT,omitempty"`
	IDLte   *pulid.ID  `json:"idLTE,omitempty"`
	// name field predicates
	Name             *string  `json:"name,omitempty"`
	NameNeq          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGt           *string  `json:"nameGT,omitempty"`
	NameGte          *string  `json:"nameGTE,omitempty"`
	NameLt           *string  `json:"nameLT,omitempty"`
	NameLte          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`
}

type Project struct {
	ID    pulid.ID            `json:"id"`
	Todos *ent.TodoConnection `json:"todos"`
}

func (Project) IsNode() {}

// ProjectWhereInput is used for filtering Project objects.
// Input was generated by ent.
type ProjectWhereInput struct {
	Not *ProjectWhereInput   `json:"not,omitempty"`
	And []*ProjectWhereInput `json:"and,omitempty"`
	Or  []*ProjectWhereInput `json:"or,omitempty"`
	// id field predicates
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNeq   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGt    *pulid.ID  `json:"idGT,omitempty"`
	IDGte   *pulid.ID  `json:"idGTE,omitempty"`
	IDLt    *pulid.ID  `json:"idLT,omitempty"`
	IDLte   *pulid.ID  `json:"idLTE,omitempty"`
	// todos edge predicates
	HasTodos     *bool                 `json:"hasTodos,omitempty"`
	HasTodosWith []*ent.TodoWhereInput `json:"hasTodosWith,omitempty"`
}

// UpdateDirectiveExampleInput is used for update DirectiveExample object.
// Input was generated by ent.
type UpdateDirectiveExampleInput struct {
	OnTypeField           *string `json:"onTypeField,omitempty"`
	ClearOnTypeField      *bool   `json:"clearOnTypeField,omitempty"`
	OnMutationFields      *string `json:"onMutationFields,omitempty"`
	ClearOnMutationFields *bool   `json:"clearOnMutationFields,omitempty"`
	OnMutationCreate      *string `json:"onMutationCreate,omitempty"`
	ClearOnMutationCreate *bool   `json:"clearOnMutationCreate,omitempty"`
	OnMutationUpdate      *string `json:"onMutationUpdate,omitempty"`
	ClearOnMutationUpdate *bool   `json:"clearOnMutationUpdate,omitempty"`
	OnAllFields           *string `json:"onAllFields,omitempty"`
	ClearOnAllFields      *bool   `json:"clearOnAllFields,omitempty"`
}

// UpdateFriendshipInput is used for update Friendship object.
// Input was generated by ent.
type UpdateFriendshipInput struct {
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	UserID    *pulid.ID  `json:"userID,omitempty"`
	FriendID  *pulid.ID  `json:"friendID,omitempty"`
}

// Properties by which OneToMany connections can be ordered.
type OneToManyOrderField string

const (
	OneToManyOrderFieldName OneToManyOrderField = "NAME"
)

var AllOneToManyOrderField = []OneToManyOrderField{
	OneToManyOrderFieldName,
}

func (e OneToManyOrderField) IsValid() bool {
	switch e {
	case OneToManyOrderFieldName:
		return true
	}
	return false
}

func (e OneToManyOrderField) String() string {
	return string(e)
}

func (e *OneToManyOrderField) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OneToManyOrderField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OneToManyOrderField", str)
	}
	return nil
}

func (e OneToManyOrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
